
`caching` 에 대한 일반적인 `design pattern` 을 사용한다.
대부분의 `app` 은 각각 다른 몇 가지 `pattern` 을 사용한다.
다음은 날씨 `app` 의 경우이다.

- 날씨 `app` 은 최신 날짜 데이터를 항상 로드하는 패턴을 채택하며,<br>네트워크 요청에 실패하는 경우에만 `cache` 로 부터 데이터를 한다.

- 날씨 `app` 의 날시를 보여주는 `icon` 의 경우, 항상 `cache` 에서 `icon` 을 가져오고 이를 `cache` 에서 찾을수 없을 경우, `network` 요청을 시도한다.

이렇게, 각각의 상황에 따라 `cache` 하는 전략도 변경되어야 한다.
이러한 부분역시 `pattern` 화 된 부분이 있으며, 이러한 `caching pattern` 을 살펴보도록 한다.

## Cache only (캐시만 사용)

**이 전략은 `logo`, `icon`, `stylesheet` 같은 `static resource` 를 처리하는데 유용하다.**

`resource` 요청을 `cache` 를 통해 처리한다.
`cache` 에서 응답을 찾을 수 없는 경우 `request` 는 실패한다.

이는 `service worker` 가 설치되는 동안 `web app` 작동에 필요한 모든 `resource` 가 이미 `caching` 한 것으로 가정한다.

이러한 `static resource` 는 절대 `resource` 를 바꿀수 없다는 의미는 아니며, 하나의 `app version` 내에서 `activated` 동안 변하지 않음을 의미한다.

만약, `resource` 내용을 변경한다면, 배포시에 `resource` 의 파일이름을 변경하고, `cache` 만료 날짜를 아주 길게 혹은 무기한으로 서버를 설정하는 방법과 비슷하다.

다음은, `service worker` 가 `activated` 되면, 필요한 파일을 다시 가져와 `cache` 에 저장할 수 있다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		caches.match(event.request)
	);
});
```

## Cache, falling back to network (캐시, 실패하는 경우 네트워크)

**이는 `Cache` 를 주로 사용하지만, 없으면 `network` 에 요청하는 경우 사용한다.**

 [[#Cache only (캐시만 사용)]] 와 비슷하지만, `Cache` 가 없다면, `Content` 를 `Network` 에 요청한다. 

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		caches.match(event.request).then((res) => {
			return res || fetch(event.request);
		})
	);
});
```

## Network only (네트워크만 사용)

**이는 `cache` 를 활용할 필요가 없는 `request` 를 처리하는데 유용하다.**

웹의 전통적인 모델로써, 모든 `resource` 를 `network` 에서 가져온다.
`network` 요청이 실패하면, 전체 요청이 실패한다.

>[!info] 예: `analystics pings` 

`fetch` 이벤트를 별도로 처리하지 않으면, `Network Only` 패턴이 적용된다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		fetch(event.request)
	);
});
```

## Network, falling back of cache (네트워크, 실패하는 경우 cache)

**이는 자주 변경되는 `contents` 나 가장 최신 `response` 를 보여주는것이 중요한 상황에서 사용한다.**

`Network` 로 요청을 전달하며, `Network` 요청이 실패하면, `cache` 로 부터 `response` 를 찾는다.
`Cache` 에서 찾을수 없다면 `request` 는 실패한다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		fetch(event.request).catch(() => {
			return caches.match(event.request);
		})
	);
});
```

이는 항상 최신의 컨텐츠를 내려받지만, `Network` 에 연결되지 않는 경우, 기존의 `cache` 를 반환한다.

## Cache, then network (cache 이후 network)

처음에 `cache` 를 보여주고, `network` 응답을 받은다음 기존의 `cache` 와 비교한다.
최신의 `cache` 가 아니라면, 새로운 `resource` 로 `cache` 를 업데이트 함과 동시에, 페이지를 업데이트 한다.

**이는 네트워크를 통한 최신 `content` 제공과 `cache` 의 빠른 응답이 결합된 가장 우수한 접근방식이지만, 구현 비용이 올라간다.**

>[!iwarning] 아래의 `code` 는 책에서 따로 설명해주는 `code` 는 없어서, 찾고 분석해본 `code` 이다.<br>이는 `cache` 만을 갱신하며, `page` 갱신을 위해서는 `self.clients.matchAll` 메서드를 사용하여 처리한다.

>[!info] sw.js
```js
self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request).then((cachedResponse) => {
            if (cachedResponse) {
                // 네트워크 요청을 백그라운드에서 수행하여 캐시를 갱신
                fetch(event.request).then((networkResponse) => {
                    if (networkResponse && networkResponse.status === 200) {
                        caches.open('your-cache-name').then((cache) => {
                            cache.put(event.request, networkResponse.clone());
                            // 클라이언트에게 캐시 업데이트 메시지 전송
                            self.clients.matchAll().then(clients => {
                                clients.forEach(client => {
                                    client.postMessage({ type: 'CACHE_UPDATED' });
                                });
                            });
                        });
                    }
                }).catch(() => {
                    // 네트워크 요청 실패 처리
                });
            } else {
                // 캐시에 응답이 없는 경우 네트워크에서 직접 요청
                return fetch(event.request).then((networkResponse) => {
                    if (networkResponse && networkResponse.status === 200) {
                        caches.open('your-cache-name').then((cache) => {
                            cache.put(event.request, networkResponse.clone());
                        });
                    }
                    return networkResponse;
                });
            }
            return cachedResponse;
        })
    );
});
```

>[!info] page 에서 `message` 수신 처리
```js
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'CACHE_UPDATED') {
            // 캐시가 업데이트되었음을 감지하고 페이지를 새로고침
            window.location.reload();
        }
    });
}
```

---
### clients 객체와 client 객체 

>[!info] `clients` 는 `service worker` 에서 관리하는 `client`(`browser tap`, `window`, `iframe`) 을 참조하는데 사용한다.<br><br>이는 다음과 같은 속성을 가진다.

- **`clients.matchAll()`**: `service worker` 에 제어 되고 있는 모든 `client` 를 반환<br>`client` 는 `windowClient` 객체로, `browser tap`, `window frame` 등을 나타낸다.

```js
self.clients.matchAll().then((clients) => {
	clients.forEach(client => {
		client.postMessage({ type: 'CACHE_UPDATED' });
	});
})
```

- **`clients.get(clientId)`**: 지정된 `client ID` 를 가진 `client` 를 반환<br>`client ID` 는 `self.clients.matchAll()` 에서 얻을수 있으며, 특정 클라이언트를 대상으로 작업할 때 사용한다.

```js
self.clients.get(clientId).then(client => {
    if (client) {
        client.postMessage({ type: 'UPDATE_AVAILABLE' });
    }
});
```

- **`clients.openWindow(url)`**: 새로운 브라우저 창을 열고, 지정한 `URL` 을 로드한다.<br>사용자가 클릭한 링크나 특정 `URL` 을 새창에서 열때 유용하다.

```js
self.clients.openWindow('/new-page.html').then(windowClient => {
    console.log('New window opened:', windowClient);
});
```

>[!info] `Client` 객체는 `service worker` 가 제어하는 브라우저 `tab`, `frame`, `iframe` 을 나타내며, `self.clients` 의 메서드를 통해 조작가능하다.

- **client.url**: 클라이언트(탭, 창, `iframe` ) 의 `URL`

```js
self.clients.matchAll().then(clients => {
    clients.forEach(client => {
        console.log(client.url); // 클라이언트의 URL을 출력
    });
});
```

- **`client.id`**: 클라이언트의 `unique ID` 를 반환

```js
self.clients.matchAll().then(clients => {
    clients.forEach(client => {
        console.log(client.id); // 클라이언트의 ID를 출력
    });
});
```

- **`client.postMessage(message)`**: 클라이언트에게 `message` 를 보낸다. `client` 의 `message` 이벤트 리스너에서 수신할수 있다.

```js
self.clients.matchAll().then((clients) => {
	clients.forEach((client) => {
		client.postMessage({ type: "UPDATE_AVAILABLE" });
	});
});
```

- **`client.focus()`**: `client` 의 `tab`, `frame`, `iframe` 등을 `focus` 하여 활성화<br>클라이언트가 현재 보이지 않는 상태일 때, 이 메서드를 사용하여 `client` 를 화면으로 가져올 수 있다.

```js
self.clients.matchAll().then((clients) => {
	if (clients.length > 0) {
		clients[0].focus(); // 첫번재 클라이언트 `focus`
	}
});
```

- **`client.navigate(url)`**: `client` 를 새로운 `URL` 로 이동한다. `client` 가 현재 `URL` 을 변경하도록 할수 있다.

```js
self.clients.matchAll().then((clients) => {
	if (clients.length > 0) {
		clients[0].navigate("/new-page.html");
	}
});
```

---
## Generic fallback (기본 대체 리소스)

사용자가 요청하는 `content` 가 `cache` 에 없고, `Network` 도 사용할수 없을때, 에러를 반환하는대신 `cache` 에서 `default fallback` 을 반환한다.

예를들어 사용자 `avator` 가 `cache` 에 없고, 네트워크 사용이 불가능한 경우, `app` 에 깨진 이미지를 남겨두는 대신 `default avatar`  를 표시하면 `offline` 상태를 매끄럽게 처리할수 있다.

보통은, 마지막 `fallback` 으로 다른 `pattern` 들과 함께 사용된다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		fetch(event.request).catch(() => {
			return caches.match(event.request).then((res) => {
				return res || caches.match("/generic.png");
			});
		})
	);
});
```



