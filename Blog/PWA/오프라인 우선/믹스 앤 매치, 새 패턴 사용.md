[[일반적인 캐싱 패턴]] 이 아닌, 실제 `content` 를 어떻게 `caching` 하는 새로운 방법을 직접 코드로 살펴본다.
## Cache on demand (요청에 따라 캐시)

자주 바뀌지는 않지만, `service worker` 의 `install` 이벤트 동안 `caching` 하고 싶지 않은 `resource` 는  `network` 에서 반환된 요청을 `cache` 에 저장하기 위해 `cache,falling back on network` 패턴을 확장할수 있다.

>[!info] `cache, falling back on network` 는 [[일반적인 캐싱 패턴]] 에서 내용을 살펴볼수 있다.

이 패턴을 활용하면, `network` `response`  를 받은 즉시 해당 `resource` 를 `cache` 에 저장할 수 있다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		caches.open("cache-name").then((cache) => {
			return cache.match(event.request).then((cachedResponse) => {
				return cachedResponse || fetch(event.request)
					.then((networkResponse) => {
						cache.put(event.request, networkResponse.clone());
						return networkResponse;
					});
			});
		})
	);
});
```

>[!info] `networkResponse.clone()` 을 사용하는 이유는, `stream` 기반으로 동작하며, 한번만 소비(`consumed`) 할수 있기 때문이다.<br><br> 이는 `Response` 객체의 내용을 한번 읽으면, 그 `response` `stream`  은 닫히고 더이상 사용할수 없다.<br><br>그러므로, 읽기전에 해당 내용의 복사본을 만들어 사용해야 한다.

>[!info] `stream`  은 `data` 의 연속적인 흐름을 관리하며, 사용후 자동으로 `resource` 를 해제한다.<br><br>  메모리 누수를 방지하는데 도움이 된다.

## Cache, falling back to network with frequent updates <br>(캐시, 이후 네트워크 사용해 캐시 업데이트)

최신 버전을 보여주는것보다 빠른 응답이 중요한 리소스의 경우, `cache, falling back to network` 패턴을 수정하여, 요청한 `resource` 가 `cache` 에 있을때에도 다음 요청을 위해 `network` 에서 최신 버전을 가져오도록 수정할수 있다.

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		caches.open("cache-name").then((cache) => {
			return cache.match(event.request)
				.then((cachedResponse) => {
					// fetchPromise 는 `Promise` 객체이다.
					const fetchPromise = fetch(event.request)
						.then((networkResponse) => {
							cache.put(event.request, networkResponse.clone());
							return networkResponse;
						});
					// `match` 함수는 `undefined` 를 반환할수 있으므로,
					// 아래의 로직은 유효하다.
					// 아래는 `cachedResponse` 가 `undefined` 라면,
					// `fetchPromise` 를 반환한다
					return cachedReponse || fetchPromise;
				})
		})
	);
}); 
```

이는 `cache` 를 보여주지만, 항상 `cache` 를 최신으로 업데이트하는것을 볼 수 있다.
만약, `cache` 가 없다면, 최신으로 업데이트한 `fetchPromise` 를 반환한다.
## Network, falling back to cache with frequent updates<br>(네트워크, 실패하는 경우 캐시 사용 및 빈번한 캐시 업데이트)

최신 리소스를 제공하는 것이 중요한 경우에는 `network, falling back to cache` 패턴 작용에 약간의 변화를 줄수 있다. 

```js
self.addEventListener("fetch", (event) => {
	event.respondWith(
		caches.open("cache-name")
			.then((cache) => {
				return fetch(event.request)
					.then((networkResponse) => {
						cache.put(event.request, networkResponse.clone());
						return networkResponse;
					}).catch(() => {
						return cache.match(event.request);
					});
			})
	);
});
```

이는 네트워크 연결에 성공했을때마다 네트워크 응답을 사용하고, `cache` 를 업데이트한다.

## 홈페이지에 대한 전략

책에서 만드는 홈페이지에서, `caching` 전략을 다음처럼 세운다.

1. **`cache, falling back to network with frequent update` 패턴을 사용하여 `index.html` 반환**

