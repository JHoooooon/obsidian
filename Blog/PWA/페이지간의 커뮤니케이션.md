
페이지에서 서비스 워커로 더 많은 로직을 옮길수록, 둘 사이에는 더 많은 커뮤니케이션이 필요하다.

네트워크 요청과 같은 중요한 이벤트를 휘발성 페이지에서 서비스 워커로 옮겨 어떻게 앱을 더 안정적으로 만들수 있는지 살펴본다.

만약, 신규등록을 위한 코드를 서비스워커에서 실행되는 `background sync` 이벤트로 옮겨보았다고 하자.
이 이벤트는서버를 호출하고, 업데이트된 내용을 포함하는 `JSON` 파일을 받는다.

`IndexedDB` 의 내용을 업데이트하기 위해 `JSON` 파일이 데이터를 사용하지만, 서비스 워커가 윈도우에 접근할 수 없기 때문에, `DOM` 에 내용을 업데이트 할수 없다.

대신 페이지는 새로운 내용을 확인하기 위해 몇 초마다 네트워크를 체크하고,  `DOM` 을 업데이트하는 `setInterval()` 에 의존한다.

만일, `sync` 이벤트에서 업데이트된 내용을 받는 즉시 페이지로 전송할 수 있다면 `DOM` 을 즉시 업데이트하고 불필요한 네트워크 요청을 방지할수 있을 것이다.

```js
navigator.serviceWorker.controller.postMessage("chache-current-page");
```

>[!info] serviceWorker.controller
>
>navigator.serviceWorker 는 [ServiceWorkerContainer](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer) 이다.
>
>`ServiceWorkerContainer` 는 `client` 에서 `navigator` 객체를 통해 `serviceWorker`  에 접근가능하도록 만든 `API` 이다.
>
>앞에서 말했듯, `ServiceWorker` 는 [[서비스 워커 생명주기와 캐시관리]] 에서 설명한것처럼, `Service Worker`  는 `page`  에 대한 제어를 이벤트로 받아 처리하며, 병렬로 작동한다.
>
>보통 `serviceWorkerConatiner` 는 서비스워커의 `register`, `unregister`, `update`, `serviceWorker 의 접근` 할수 있는 메서드 및 프로퍼티를 제공한다. 
>
>이러한 이유로 `page` 에서 `ServiceWorker` 에 접근하기 위해서는, `sw.js` 상의 `self` 가 아닌, `navigator.serviceWorker.controller` 를 통해 접근한다.
>
>`navigatore.serviceWorker.controller` 는 `activating` 혹은 `activated` 상태라면, `serviceWorker` 객체를 반환하지만, 그렇지 않다면 `NULL` 을 반환한다.
>
>`Docs` 를 보니, `ServiceWorker` 에 `ServiceWorkerContainer` 라는 개념을 지속적으로 사용하여, 일반적인 `ServiceWorker` 와의 차이점을 구분해야 이해할수 있었다..

>[!info] postMessage()
>`ServiceWorker` 에서 제공하는 메서드로, 현제 사용중인 `serviceWorker` 에 `message` 를 보내는 메서드이다.  

>[!info] sw.js
```js
self.addEventListener("message", (event) => {
	if (event.data === "cache-current-page") {
		const sourceUrl = event.source.url;
		if (event.source.visibilityState === "visible") {
			// sourceUrl 파일 캐싱
		} else {
			// 나중에 캐싱할수 있도록 sourceUrl 관련 파일 큐에 넣기
		}
	}
});
```

## 서비스워커에서 열려있는 모든 윈도우로 메시지 보내기

`service worker` 에서 `page` 로 `message` 를 보내는 것은 `page` 에서 `service worker` 로 `message` 를 게시하는것과 비슷하다.

이는 `global object` 인 `clients`객체를 사용한다면, 현재 `service worker` 범주 안에 열려있는 `windowClient`  를 가져올수 있다.

그리고 `clients` 객체는 `matchAll` 메서드를 가지고 있으며, 이 메서드는 `service worker` 범주 내에 열려 있는 모든 `window`를 가져오는데 사용된다.

```js
self.clients.matchAll().then((clients)=> {
	clients.forEach((client) => {
		if (client.url.includes("/my-account")) {
			client.postMessage(`Hi Client ${client.id}`);
		}
	});
});
```

이는 현재 `service worker` 가 제어하는모든 클라이언트를 가져와 하나씩 돌며 `/my-account` 페이지를 표시하고 있는 윈도우로 `message` 를 보낸다.

다음은 `client` 에서 `message` 를 수신하는 이벤트 리스너를 사용하여 내용을 받는다

```js
self.addEventListener("message", (event) => {
	console.log(event.data);
});

// Hi client: b85b7e3d-a893-...
```

>[!warning] `service worker` 이벤트 외부에 `self.clients.matchAll` 이후, `client.postMessage(...)` 을 사용하는건 제대로 작동하지 않을수 있다.<br><br>이는 이벤트 외부에 있으므로, `service worker` 가 `script` 로드할때 해당 코드를 바로 실행시키기 때문이다.<br><br>이 시점에서 `service worker` 가 `install` 전이고, 어떠한 `client` 도 `message` 이벤트를 기다리고 있지 않은 시점이다.

다음은 `install` 이벤트를 수정한 코드이다.
캐싱이 완료된 이후 모든 클라이언트에게 메시지를 보낸다.

```js
self.addEventListener("install", (event) => {
	event.waitUntil(
		caches.open(CACHE_NAME).then((cache) => {
			return cache.addAll(CACHE_URLS);
		}).then(() => {
			return self.clients.matchAll({
				includeUncontrolled: true
			});
		}).then((clients) => {
			clients.forEach((client) => {
				client.postMessage("cacheing-complete");
			});
		})
	);
});
```

책에서는 **사용자가 처음 방문하면 서비스워커가 설치되고 활성화 된다.하지만 페이지는 여전히 서비스 워커에 의해 제어되지 않는다.** 라고 말한다.

이는 잘못 이해할 여지가 있어 보인다.
내가 이해한 `service worker` 의 작동은 [[서비스 워커 생명주기와 캐시관리]] 에 명시한대로, 이루어진다.

처음 방문하면 설치되고 활성화 되는데, 서비스워커에 의해 제어되는 시점은 활성화된 이후 부터이다. 
여기에서는 `install` 단계에서 이루어지는 `event listener` 이므로, `installed` 이후에 작동한다.

실상, `installed` 된 이후 `activating` 단계로 넘어가는것으로 이해했지만, 좀더 구분을 명확하게 하기 위해 `install` 이벤트가 발생한후, 라고 명시하는것이 좋을 듯 싶다.

이는 아직 `acvitated` 된 상태가 아니므로 `page` 제어가 되지 않는 시점이다.

>[!warning] 위에 **설치되고 활성화 된다.** 라는 부분에 의해 한참을 들여다 봤다...<br><br>뭐.. 내가 잘못이해한것일수 있다. 나도 현재 알아가는 과정이므로... 

이렇게, `page` 제어가 되지 않는 시점에서, `client` 에 `postMessage` 를 보내면, `message` 이벤트를 받지 못할수있다.

이를 처리하기 위해 `self.clients.matchAll({ includeUncontrolled: true })` 를 사용하여, `uncontrolled clinet` 들 역시 포함한다.

>[!warning] 이는 말그대로 제어되지 않는 `page` 역시 포함되므로, 해당 `page` 에서 `service worker` 의 기능을 사용하지는 못한다.

## 서비스워커에서 특정 윈도우로 메시지 전송

`self.clients` 는 `matchAll` 뿐만 아니라, 단일 `clinet` 를 가져오기 위해서 `get` 메서드도 제공한다. 이는 인자값으로 `client ID` 를 넣어 호출하면, 해당하는 `client` 를 가져온다.

```js
self.clients.get("d2096ced-8f96-...").then((client) => {
	client.postMessage(`Hi window, you are currently ${client.visibilityState}`);
});
```


`client ID` 를 알수있는방법은 총 $2$ 가지이다.

- 모든 클라언트를 순회한후, 각 객체의 `ID` 속성을 확인하는 것이다.
- `message` 이벤트의 `source` 속성에서 `ID` 속성을 확인한다.

```js
self.clients.matchAll().then((clinets) => {
	clients.forEach(client => {
		self.clients
			.get(client.id)
			.then(client => {
				client.postMessage("Message using clients.matchAll()")
			})
	});
});
```

```js
self.addEventListener("message", (event) => {
	self.clients.get(event.source.id)
		.then((client) => {
			client.postMessage(`Messaging using clients.get(event.source.id)`);
		});
});
```

>[!warning] 위의 예시는 효율적이지 못하며, 과한 부분이 있다.<br>사실 아래처럼 하는것이 적합할 것이다.

```js
self.clients.matchAll().then((clinets) => {
	clients.forEach(client => {
		client.postMessage("Message using clients.matchAll()");
	});
});
```

```js
self.addEventListener("message", (event) => {
	event.source.postMessage(`Messaging using clients.get(event.source.id)`);
});
```

더 일반적인 사례는 `ID` 배열을 모아놓고, 처리 완료후 모아놓은 `ID` 배열의 `client` 에게 메시지를 전송해야 하는 경우 사용할수 있을것 같다.

## Message Channel  로 커뮤니티 채널 열어두기

`postMessage` 가 받는 첫번째 파라미터는 메시지의 내용이었다.
이 메서드는 $2$ 번재 인자로 [Message Channel](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel) 를 받는다.

이는 양방향 커뮤니케이션을 할수 있도록 `channel` 을 열어두고, 메시지를 주고 받는데 사용할수 있다.

```js
const msgChan = new MessageChannel();

msgChan.port1.addEventListener("message", (msg) => {
	console.log(`Message received at port 1: ${msg.data}`);
});

msgChan.port2.postMessage("Hi from port 2");
```

서비스워커와 윈도우가 두개의 포트를 나눠갖고, 이후 양방향 통신에 활용한다.

>[!info] window
```js
const msgChan = new MessageChannel();
const msg = {
	action: "triple",
	value: 2,
};

msgChan.port1.addEventListener("message", (event) => {
	console.log(`Message received in page: ${event.data}`);
	// "Message received in page: 6"
});

navigator.serviceWorker.controller.postMessage(msg, [msgChan.port2]);
```

>[!info] sw.js
```js
self.addEventListener("message", (event) => {
	const data = event.data;
	const openPort = event.ports[0];

	if (data.action === "triple") {
		openPort.postMessage(data.value * 3);
	}
})
```

## 윈도우간 통신

서로다른 윈도우간의 통신 방법에대해서 살펴본다

>[!info] 구 버전에서 윈도우끼리 메시지를 주고 받으려면 `hack`  을 사용해야 했다고한다.<br>`이는 쿠키, 로컬스토리지, 서버 메시지 작성등을 의미한다.`<br><br>하지만 `service worker` 는 이러한 역할을 대체하여 처리할수 있다.<br><br>`service worker` 는 범위 내에 열려있는 모든 윈도우에 접근할수 있고, 각 윈도우 사이에서 연락책 역할을 수행할수 있다.

```js
$(document).ready(() => {
	$.getJSON("/events/json", renderEvents);
	if ("serviceWorker" in naviagator) {
		$("#logout-button").click((event) => {
			if (navigator.serviceWorker.controller) {
				event.preventDefault();
				navigator.serviceWorker.controller.postMessage({
					action: "logout",
				});
			}
		});
	};
});
```

이는 `service worker` 작동을 확인하고, 있다면, `click` 이벤트 리스너를 `logout` 액션이 발생하도록, `message` 를 보낸다.

이는 점진적으로 좋은 예이다.
우선 로그아웃 링크는 간단한 `HTML` 링크 형태로 구현되며, 이 상태로도 완전하게 작동한다.
또한, 이를 통해 여러 윈도우창에서 동시에 로그아웃처리 가능하다.

>[!info] sw.js
```js
self.addEventListener("message", (event) => {
	const data = event.data;
	if (data.action === "logout") {
		self.clients.matchAll().then((clients) => {
			clients.forEach((client) => {
				if (client.url.includes("/my-account")) {
					client.postMessage({
						action: "navigate",
						url: "/",
					});
				};
			});
		});
	}
});
```

기존의 `code` 에서 변경한
`service worker`  가 보낸 `message`  를 수신하는 페이지이다.

```js
$(document).ready(() => {
	$.getJSON("/event.json", renderEvents);
	if ("serviceWorker" in navigator) {
		navigator.serviceWorker.addEventListener("message", (event) => {
			const data = event.data;
			if (data.action === "navigate") {
				window.location.href = data.url;
			}
		});
		$("#logout-button").click((event) => {
			if (navigator.serviceWorker.controller) {
				event.preventDefault();
				navigator.serviceWorker.controller.postMessage({
					action; "logout",
				});
			}
		});
	}
});
```

위의 작동 방식의흐름은 다음과 같다.

1. `/my-account` 에서 `logout-button` 을 누른다.
2. `/my-account` 에서 `service worker` 가 있고, `active` 상태라면, `postmessage` 로 `action: "logout"` 을 보낸다.
3. `sw.js` 에서 `message` 이벤트로 `event` 를 받는다
4. `sw.js` 에서 `event.data.action`  이 `logout` 이라면, 모든 `clients` 에게 `postMessage({ action: "navigate", url: "/" })` 을 보낸다.
5. `/my-account` 에서 `message` 이벤트를 받고, `action` 이 `navigate` 라면, `window.location.href` 에 `event.data.url` 을 전달하여 `page`  이동한다.

이는 `service worker` 에 의해 제어되는 모든 `window frame`, `tab`, `iframe` 등에서 처리된다. 

>[!info] 마치 `react`  의 `global state` 같은 느낌이...

## 동기화 이벤트에서 페이지로 메시지 보내기

만약 `service worker` 의 작업이 완료된 이후, `DOM` 을 업데이트 하는 방법을 원한다면, `message`  를 사용해서 처리할수 있다.

한번 생각해보자. 만약 `client` 의 어느 페이지에서 `indexedDB` 로 업데이트가 일어날때, `backgroundSync` 를 사용해서 `service worker` 가 작동한다고 가정하자.

그럼 `self.addEvenetListener("sync", (event) => {...})`  에서 해당 로직을 처리하기 위해, `indexedDB` 의 데이터를 가져오고, `fetch API` 를 사용하여 `server` 로 전송한다.

이후, `server` 에서 처리완료된 응답값을 `indexedDB`  에 업데이트한다.
생각해보면, 이는 `page` 에 적용되지 않는다는것을 알수 있다.

단지 `indexedDB` 에 데이터만 업데이트할 뿐이지, `page`  에서는 비동기로 인한 `server` 에서의 응답값을 받아 완료되었는지 알지 못한다.

이러한 처리를 위해 `page`  로 메시지를 보내, 처리 완료되었음을 알려, `page` 를 업데이트 하는데 사용할수 있다.

```js
const postReservationDetails = async (reservation) => {
	const clients = await self.clients.matchAll({
		includeUncontrolled: true
	});

	clients.forEach(client => {
		client.postMessage({
			action: "update-reservation",
			reservation,
		}
	});
};

const syncReservations = async () => {
	const reservations = await getReservations("idx_status", "Sending"))
	return Promise.all(
		reservations.map(async (reservation) => {
			const reservationUrl = createReservationUrl(reservation);
			const data = (await fetch(reservationUrl)).json()
			const updateReservation = await updateInObjectStore(
				"reservations",
				data.id,
				data,
			);
			await postReservationDetails(data);
		})
	);
};
```

이 코드를 보면 `postReservationDetails`  에서 `reservation data` 를 받아, 인자로 넘겨준다.
이후, `service worker` 가 제어하고있는 `clients` 에 `update` 되었다는 `message` 를 전송한다.

다음은 `app.js` 의 내용이다.

>[!info] app.js
```js
navigator.serviceWorker.addEventListener("message", (event) => {
	const data = event.data;
	if (data.action === "nvigate") {
		window.location.href = data.url;
	}
	if (data.action === "update-reservation") {
		updateReservationDisplay(data.reservation);
	}
});
```

이는 `client` 에서 `message`  를 받아 처리하는 로직이다.
분기처리를 하여, 원하는 메시지를 받도록 처리한다.

>[!info] `updateReservationDisplay` 함수가 `DOM` 을 업데이트하는 함수이다.


