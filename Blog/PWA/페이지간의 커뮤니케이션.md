
페이지에서 서비스 워커로 더 많은 로직을 옮길수록, 둘 사이에는 더 많은 커뮤니케이션이 필요하다.

네트워크 요청과 같은 중요한 이벤트를 휘발성 페이지에서 서비스 워커로 옮겨 어떻게 앱을 더 안정적으로 만들수 있는지 살펴본다.

만약, 신규등록을 위한 코드를 서비스워커에서 실행되는 `background sync` 이벤트로 옮겨보았다고 하자.
이 이벤트는서버를 호출하고, 업데이트된 내용을 포함하는 `JSON` 파일을 받는다.

`IndexedDB` 의 내용을 업데이트하기 위해 `JSON` 파일이 데이터를 사용하지만, 서비스 워커가 윈도우에 접근할 수 없기 때문에, `DOM` 에 내용을 업데이트 할수 없다.

대신 페이지는 새로운 내용을 확인하기 위해 몇 초마다 네트워크를 체크하고,  `DOM` 을 업데이트하는 `setInterval()` 에 의존한다.

만일, `sync` 이벤트에서 업데이트된 내용을 받는 즉시 페이지로 전송할 수 있다면 `DOM` 을 즉시 업데이트하고 불필요한 네트워크 요청을 방지할수 있을 것이다.

```js
navigator.serviceWorker.controller.postMessage("chache-current-page");
```

>[!info] serviceWorker.controller
>
>navigator.serviceWorker 는 [ServiceWorkerContainer](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer) 이다.
>
>`ServiceWorkerContainer` 는 `client` 에서 `navigator` 객체를 통해 `serviceWorker`  에 접근가능하도록 만든 `API` 이다.
>
>앞에서 말했듯, `ServiceWorker` 는 [[서비스 워커 생명주기와 캐시관리]] 에서 설명한것처럼, `Service Worker`  는 `page`  에 대한 제어를 이벤트로 받아 처리하며, 병렬로 작동한다.
>
>보통 `serviceWorkerConatiner` 는 서비스워커의 `register`, `unregister`, `update`, `serviceWorker 의 접근` 할수 있는 메서드 및 프로퍼티를 제공한다. 
>
>이러한 이유로 `page` 에서 `ServiceWorker` 에 접근하기 위해서는, `sw.js` 상의 `self` 가 아닌, `navigator.serviceWorker.controller` 를 통해 접근한다.
>
>`navigatore.serviceWorker.controller` 는 `activating` 혹은 `activated` 상태라면, `serviceWorker` 객체를 반환하지만, 그렇지 않다면 `NULL` 을 반환한다.
>
>`Docs` 를 보니, `ServiceWorker` 에 `ServiceWorkerContainer` 라는 개념을 지속적으로 사용하여, 일반적인 `ServiceWorker` 와의 차이점을 구분해야 이해할수 있었다..

>[!info] postMessage()
>`ServiceWorker` 에서 제공하는 메서드로, 현제 사용중인 `serviceWorker` 에 `message` 를 보내는 메서드이다.  

>[!info] sw.js
```js
self.addEventListener("message", (event) => {
	if (event.data === "cache-current-page") {
		const sourceUrl = event.source.url;
		if (event.source.visibilityState === "visible") {
			// sourceUrl 파일 캐싱
		} else {
			// 나중에 캐싱할수 있도록 sourceUrl 관련 파일 큐에 넣기
		}
	}
});
```

## 서비스워커에서 열려있는 모든 윈도우로 메시지 보내기

`service worker` 에서 `page` 로 `message` 를 보내는 것은 `page` 에서 `service worker` 로 `message` 를 게시하는것과 비슷하다.

이는 `global object` 인 `clients`객체를 사용한다면, 현재 `service worker` 범주 안에 열려있는 `windowClient`  를 가져올수 있다.

그리고 `clients` 객체는 `matchAll` 메서드를 가지고 있으며, 이 메서드는 `service worker` 범주 내에 열려 있는 모든 `window`를 가져오는데 사용된다.

```js
self.clients.matchAll().then((clients)=> {
	clients.forEach((client) => {
		if (client.url.includes("/my-account")) {
			client.postMessage(`Hi Client ${client.id}`);
		}
	});
});
```

이는 현재 `service worker` 가 제어하는모든 클라이언트를 가져와 하나씩 돌며 `/my-account` 페이지를 표시하고 있는 윈도우로 `message` 를 보낸다.

다음은 `client` 에서 `message` 를 수신하는 이벤트 리스너를 사용하여 내용을 받는다

```js
self.addEventListener("message", (event) => {
	console.log(event.data);
});

// Hi client: b85b7e3d-a893-...
```

>[!warning] `service worker` 이벤트 외부에 `self.clients.matchAll` 이후, `client.postMessage(...)` 을 사용하는건 제대로 작동하지 않을수 있다.<br><br>이는 이벤트 외부에 있으므로, `service worker` 가 `script` 로드할때 해당 코드를 바로 실행시키기 때문이다.<br><br>이 시점에서 `service worker` 가 `install` 전이고, 어떠한 `client` 도 `message` 이벤트를 기다리고 있지 않은 시점이다.

다음은 `install` 이벤트를 수정한 코드이다.
캐싱이 완료된 이후 모든 클라이언트에게 메시지를 보낸다.

```js
self.addEventListener("install", (event) => {
	event.waitUntil(
		caches.open(CACHE_NAME).then((cache) => {
			return cache.addAll(CACHE_URLS);
		}).then(() => {
			return self.clients.matchAll({
				includeUncontrolled: true
			});
		}).then((clients) => {
			clients.forEach((client) => {
				client.postMessage("cacheing-complete");
			});
		})
	);
});
```

책에서는 **사용자가 처음 방문하면 서비스워커가 설치되고 활성화 된다.하지만 페이지는 여전히 서비스 워커에 의해 제어되지 않는다.** 라고 말한다.

이는 잘못 이해할 여지가 있어 보인다.
내가 이해한 `service worker` 의 작동은 [[서비스 워커 생명주기와 캐시관리]] 에 명시한대로, 이루어진다.

처음 방문하면 설치되고 활성화 되는데, 서비스워커에 의해 제어되는 시점은 활성화된 이후 부터이다. 
여기에서는 `install` 단계에서 이루어지는 `event listener` 이므로, `installed` 이후에 작동한다.

실상, `installed` 된 이후 `activating` 단계로 넘어가는것으로 이해했지만, 좀더 구분을 명확하게 하기 위해 `install` 이벤트가 발생한후, 라고 명시하는것이 좋을 듯 싶다.

이는 아직 `acvitated` 된 상태가 아니므로 `page` 제어가 되지 않는 시점이다.

>[!warning] 위에 **설치되고 활성화 된다.** 라는 부분에 의해 한참을 들여다 봤다...<br><br>뭐.. 내가 잘못이해한것일수 있다. 나도 현재 알아가는 과정이므로... 

이렇게, `page` 제어가 되지 않는 시점에서, `client` 에 `postMessage` 를 보내면, `message` 이벤트를 받지 못할수있다.

이를 처리하기 위해 `self.clients.matchAll({ includeUncontrolled: true })` 를 사용하여, `uncontrolled clinet` 들 역시 포함한다.

>[!warning] 이는 말그대로 제어되지 않는 `page` 역시 포함되므로, 해당 `page` 에서 `service worker` 의 기능을 사용하지는 못한다.

## 서비스워커에서 특정 윈도우로 메시지 전송

`self.clients` 는 `matchAll` 뿐만 아니라, 단일 `clinet` 를 가져오기 위해서 `get` 메서드도 제공한다. 이는 인자값으로 `client ID` 를 넣어 호출하면, 해당하는 `client` 를 가져온다.

```js
self.clients.get("d2096ced-8f96-...").then((client) => {
	client.postMessage(`Hi window, you are currently ${client.visibilityState}`);
});
```


`client ID` 를 알수있는방법은 총 $2$ 가지이다.

- 모든 클라언트를 순회한후, 각 객체의 `ID` 속성을 확인하는 것이다.
- `message` 이벤트의 `source` 속성에서 `ID` 속성을 확인한다.

```js
self.clients.matchAll().then((clinets) => {
	clients.forEach(client => {
		self.clients
			.get(client.id)
			.then(client => {
				client.postMessage("Message using clients.matchAll()")
			})
	});
});
```

```js
self.addEventListener("message", (event) => {
	self.clients.get(event.source.id)
		.then((client) => {
			client.postMessage(`Messaging using clients.get(event.source.id)`);
		});
});
```

>[!warning] 위의 예시는 효율적이지 못하며, 과한 부분이 있다.<br>사실 아래처럼 하는것이 적합할 것이다.

```js
self.clients.matchAll().then((clinets) => {
	clients.forEach(client => {
		client.postMessage("Message using clients.matchAll()");
	});
});
```

```js
self.addEventListener("message", (event) => {
	event.source.postMessage(`Messaging using clients.get(event.source.id)`);
});
```

더 일반적인 사례는 `ID` 배열을 모아놓고, 처리 완료후 모아놓은 `ID` 배열의 `client` 에게 메시지를 전송해야 하는 경우 사용할수 있을것 같다.

## Message Channel  로 커뮤니티 채널 열어두기

`WindowClient`혹은 `service worker` 객체가 메시지를 게시하는 방법 및 `postMessage` 가 받는 첫번째 파라미터는 메시지의 내용이었다.
