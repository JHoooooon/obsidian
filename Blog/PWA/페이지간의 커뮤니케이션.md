
페이지에서 서비스 워커로 더 많은 로직을 옮길수록, 둘 사이에는 더 많은 커뮤니케이션이 필요하다.

네트워크 요청과 같은 중요한 이벤트를 휘발성 페이지에서 서비스 워커로 옮겨 어떻게 앱을 더 안정적으로 만들수 있는지 살펴본다.

만약, 신규등록을 위한 코드를 서비스워커에서 실행되는 `background sync` 이벤트로 옮겨보았다고 하자.
이 이벤트는서버를 호출하고, 업데이트된 내용을 포함하는 `JSON` 파일을 받는다.

`IndexedDB` 의 내용을 업데이트하기 위해 `JSON` 파일이 데이터를 사용하지만, 서비스 워커가 윈도우에 접근할 수 없기 때문에, `DOM` 에 내용을 업데이트 할수 없다.

대신 페이지는 새로운 내용을 확인하기 위해 몇 초마다 네트워크를 체크하고,  `DOM` 을 업데이트하는 `setInterval()` 에 의존한다.

만일, `sync` 이벤트에서 업데이트된 내용을 받는 즉시 페이지로 전송할 수 있다면 `DOM` 을 즉시 업데이트하고 불필요한 네트워크 요청을 방지할수 있을 것이다.

```js
navigator.serviceWorker.controller.postMessage("chache-current-page");
```

>[!info] serviceWorker.controller
>
>navigator.serviceWorker 는 [ServiceWorkerContainer](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer) 이다.
>
>`ServiceWorkerContainer` 는 `client` 에서 `navigator` 객체를 통해 `serviceWorker`  에 접근가능하도록 만든 `API` 이다.
>
>앞에서 말했듯, `ServiceWorker` 는 [[서비스 워커 생명주기와 캐시관리]] 에서 설명한것처럼, `Service Worker`  는 `page`  에 대한 제어를 이벤트로 받아 처리하며, 병렬로 작동한다.
>
>보통 `serviceWorkerConatiner` 는 서비스워커의 `register`, `unregister`, `update`, `serviceWorker 의 접근` 할수 있는 메서드 및 프로퍼티를 제공한다. 
>
>이러한 이유로 `page` 에서 `ServiceWorker` 에 접근하기 위해서는, `sw.js` 상의 `self` 가 아닌, `navigator.serviceWorker.controller` 를 통해 접근한다.
>
>`navigatore.serviceWorker.controller` 는 `activating` 혹은 `activated` 상태라면, `serviceWorker` 객체를 반환하지만, 그렇지 않다면 `NULL` 을 반환한다.
>
>`Docs` 를 보니, `ServiceWorker` 에 `ServiceWorkerContainer` 라는 개념을 지속적으로 사용하여, 일반적인 `ServiceWorker` 와의 차이점을 구분해야 이해할수 있었다..

>[!info] postMessage()
>`ServiceWorker` 에서 제공하는 메서드로, 현제 사용중인 `serviceWorker` 에 `message` 를 보내는 메서드이다.  

>[!info] sw.js
```js
self.addEventListener("message", (event) => {
	if (event.data === "cache-current-page") {
		const sourceUrl = event.source.url;
		if (event.source.visibilityState === "visible") {
			// sourceUrl 파일 캐싱
		} else {
			// 나중에 캐싱할수 있도록 sourceUrl 관련 파일 큐에 넣기
		}
	}
});
```

## 서비스워커에서 열려있는 모든 윈도우로 메시지 보내기

`service worker` 에서 `page` 로 `message` 를 보내는 것은 `page` 에서 `service worker` 로 `message` 를 게시하는것과 비슷하다.

이는 `global object` 인 `clients`객체를 사용한다면, 현재 `service worker` 범주 안에 열려있는 `windowClient`  를 가져올수 있다.

그리고 `clients` 객체는 `matchAll` 메서드를 가지고 있으며, 이 메서드는 `service worker` 범주 내에 열려 있는 모든 `window`를 가져오는데 사용된다.

```js
self.clients.matchAll().then((clients)=> {
	clients.forEach((client) => {
		if (client.url.includes("/my-account")) {
			client.postMessage(`Hi Client ${client.id}`);
		}
	});
});
```
