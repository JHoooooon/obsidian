
`background` 동기화의 본질은 `page context` 에서 이루어지는 작업을 `background` 로 옮기는것이다.

`background` 에서 작업을 처리하면, 쉽게 휘발되는 `webpage` 의 특성에서 벗어날수 있다.
>[!info] `server` 가 `down` 되었거나, `webpage` 는 언제든 닫힐수 있다.

이러한 환경에서 사용자 기기에 `brower` 가 설치되어 있는 한 `background sync` 는 성공적으로 완료될때까지 사라지지 않는다.

이는 `page` 가 닫혀도, 계속 진행되어야 하는 작업을 `background` 에 동기화사용할수 있도록 제공한다.

>[!info] 캘린더에 이벤트를 추가하거나, 해야할일 목록 중 하나를 완료 표시하는 작업들의 완료를 보장한다.

이러한 방식은 간단하게 구현된다.
이는 `page` 에서 `Ajax`  호출같은 작업을 수행하는 대신 동기화 이벤트를 등록하면 된다.

```js
navigator.serviceWorker.ready.then((registration) => {
	registration.sync.register("send-messages");
})
```

이는 활성화된 `service worker` 의 등록 객체를 받아와 `"send-messages"` 라는 동기화 이벤트를 등록한다. 

다음은, `service worker` 에 `sync` 이벤트 리스너를 추가하며, 이를 통해 동기화 이벤트를 수신한다.

```js
self.addEventListener("sync", (event) => {
	if (event.tag === "send-message") {
		// resolve 될때까지 실행
		// waitUntil 은 이벤트 종료를 요청하기전가지, 이벤트를 유지해준다.
		event.waitUntil(() => {
			const send = sendMessages();
			if (send) {
				// 성공 
				return Promise.resolve();
			} else {
				// 실패
				// 실패시, taskqueue 에 들어가 다시 비동기로써 실행
				return Promise.reject();
			}
		})
	}	
});
```

## The SyncManager

동기화 이벤트 등록과 수신에 대한 코드를 살펴보았다.
동기화 이벤트와 관련된 모든 상호작용은 `SyncManager` 를 통해 이루어진다.

>[!info] [SyncManger API](https://caniuse.com/?search=syncmanager) 관련해서, 제공하는 `browser` 가 적다.<br>이는 효율적으로 사용가능하지만, `fallback` 형식의 코드를 구현하기도 해야 한다.

`SyncManager` 는 동기화 이벤트를 등록하고, 현재 등록된 동기화 작업을 가져오는 기능을 겢공하는 `service worker` 의 `interface` 이다.

### SyncManager 접근하기

활성화된 `service worker` 등록 객체를 통하여 `SyncManager` 에 접근할수 있다.
등록 객체를 가져오는 방법은 `service worker`  에서 가져오는지, 아니면 `page` 에서 직접 가져오는지에 따라 조금씩 달라진다.

`service worker` 내에서는 `global object`  를 통해 쉽게 `service worker`  에 접근가능하다

```js
self.registraion;
```

반면, `page` 에서 가져오는 경우에는 현재 활성화된 `service worker` 객체에 접근가능하지 확인하기 위해, `ready` 를 호출하여, 접근해야 한다.

```js
navigatior.serviceWorker.ready.then((registration) =>{...})
```

이렇게 `service worker` 의 등록 객체를 가져왔따면, `SyncManager`  를 통한 상호작용은 `service worker `에서 하던 페이지에서 하던 상관없다.

### Event 등록

동기화 이벤트를 등록하려면 `SyncManager` 에서 등록하고자 하는 `동기화 이벤트 이름`(`TagName`) 을 파라미터로 `register` 함수를 호출한다.

다음은 `send-messages` 이벤트를 등록한다.

```js
self.registration.sync.register("send-messages");
```

`service worker` 가 제어하는 `page` 에서 같은 `event` 를 등록하려면 다음과 같은 `code` 를 사용한다.

```js
navigator.serviceWorker.ready.then((registraion) => {
	registration.sync.register("send-messages");
});
```

### 동기화 이벤트

동기화 이벤트를 등록하면 다음과 같은 일이 일어난다.

1. **`SyncManager`  는 간단한 동기화 이벤트 태그 목록을 유지한다.**<br>구현은 되어있지 않으며, 구현에 대한 로직은 전적으로 `service worker` 의 `sync` 이벤트 `listener` 의 `code` 에 달려있다.

2. **`SyncManager` 는 다음과 같은 경우 `sync` 이벤트를 발생시킨다.**<br>1. 동기화 이벤트 등록 직후<br>2. 사용자 상태가 `offline` 에서 `online` 으로 변경<br>3. 