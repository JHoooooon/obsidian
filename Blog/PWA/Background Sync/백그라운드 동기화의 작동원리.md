
`background` 동기화의 본질은 `page context` 에서 이루어지는 작업을 `background` 로 옮기는것이다.

`background` 에서 작업을 처리하면, 쉽게 휘발되는 `webpage` 의 특성에서 벗어날수 있다.
>[!info] `server` 가 `down` 되었거나, `webpage` 는 언제든 닫힐수 있다.

이러한 환경에서 사용자 기기에 `brower` 가 설치되어 있는 한 `background sync` 는 성공적으로 완료될때까지 사라지지 않는다.

이는 `page` 가 닫혀도, 계속 진행되어야 하는 작업을 `background` 에 동기화사용할수 있도록 제공한다.

>[!info] 캘린더에 이벤트를 추가하거나, 해야할일 목록 중 하나를 완료 표시하는 작업들의 완료를 보장한다.

이러한 방식은 간단하게 구현된다.
이는 `page` 에서 `Ajax`  호출같은 작업을 수행하는 대신 동기화 이벤트를 등록하면 된다.

```js
navigator.serviceWorker.ready.then((registration) => {
	registration.sync.register("send-messages");
})
```

이는 활성화된 `service worker` 의 등록 객체를 받아와 `"send-messages"` 라는 동기화 이벤트를 등록한다. 

다음은, `service worker` 에 `sync` 이벤트 리스너를 추가하며, 이를 통해 동기화 이벤트를 수신한다.

```js
self.addEventListener("sync", (event) => {
	if (event.tag === "send-message") {
		// resolve 될때까지 실행
		// waitUntil 은 이벤트 종료를 요청하기전가지, 이벤트를 유지해준다.
		event.waitUntil(() => {
			const send = sendMessages();
			if (send) {
				// 성공 
				return Promise.resolve();
			} else {
				// 실패
				// 실패시, taskqueue 에 들어가 다시 비동기로써 실행
				return Promise.reject();
			}
		})
	}	
});
```

## :LiFolderSync: The SyncManager

동기화 이벤트 등록과 수신에 대한 코드를 살펴보았다.
동기화 이벤트와 관련된 모든 상호작용은 `SyncManager` 를 통해 이루어진다.

>[!info] [SyncManger API](https://caniuse.com/?search=syncmanager) 관련해서, 제공하는 `browser` 가 적다.<br>이는 효율적으로 사용가능하지만, `fallback` 형식의 코드를 구현하기도 해야 한다.

`SyncManager` 는 동기화 이벤트를 등록하고, 현재 등록된 동기화 작업을 가져오는 기능을 겢공하는 `service worker` 의 `interface` 이다.

### :LiActivity: SyncManager 접근하기

활성화된 `service worker` 등록 객체를 통하여 `SyncManager` 에 접근할수 있다.
등록 객체를 가져오는 방법은 `service worker`  에서 가져오는지, 아니면 `page` 에서 직접 가져오는지에 따라 조금씩 달라진다.

`service worker` 내에서는 `global object`  를 통해 쉽게 `service worker`  에 접근가능하다

```js
self.registraion;
```

반면, `page` 에서 가져오는 경우에는 현재 활성화된 `service worker` 객체에 접근가능하지 확인하기 위해, `ready` 를 호출하여, 접근해야 한다.

```js
navigatior.serviceWorker.ready.then((registration) =>{...})
```

이렇게 `service worker` 의 등록 객체를 가져왔따면, `SyncManager`  를 통한 상호작용은 `service worker `에서 하던 페이지에서 하던 상관없다.

### ® Event 등록

동기화 이벤트를 등록하려면 `SyncManager` 에서 등록하고자 하는 `동기화 이벤트 이름`(`TagName`) 을 파라미터로 `register` 함수를 호출한다.

다음은 `send-messages` 이벤트를 등록한다.

```js
self.registration.sync.register("send-messages");
```

`service worker` 가 제어하는 `page` 에서 같은 `event` 를 등록하려면 다음과 같은 `code` 를 사용한다.

```js
navigator.serviceWorker.ready.then((registraion) => {
	registration.sync.register("send-messages");
});
```

### :LiSyncSmall: 동기화 이벤트

동기화 이벤트를 등록하면 다음과 같은 일이 일어난다.

1. **`SyncManager`  는 간단한 동기화 이벤트 태그 목록을 유지한다.**<br>구현은 되어있지 않으며, 구현에 대한 로직은 전적으로 `service worker` 의 `sync` 이벤트 `listener` 의 `code` 에 달려있다.

2. **`SyncManager` 는 다음과 같은 경우 `sync` 이벤트를 발생시킨다.**<br>👉 동기화 이벤트 등록 직후<br>👉 사용자 상태가 `offline` 에서 `online` 으로 변경<br>👉 성공적으로 완료되지 않은 `sync` 이벤트가 있을 경우, 매 분마다

3. **`service worker` 는 동기화 이벤트를 `promise` 형식으로 수신하고, 처리할수 있다.**<br>👉 `promise` 가 `resolve` 되면, `SyncManager` 에서 해당 `sync` `event` 가 삭제된다.<br>👉 `reject` 되면,  `SyncManager` 는 다음 동기화 시점에 다시 시도될 수 있도록 `SyncManager` 에 남기게 된다.

### :LiTag: Event Tag

`Event Tag` 는 유일해야 한다.
`SyncManager`  에 이미 존재하는 `Tag` 명으로 `Sync` 이벤트를 등록하면, `SyncManager` 는 이를 무시하고 중복으로 추가하지 않는다.

`SyncManager` 의 가장 유용한 특징중 하나로써, 많은 수의 비슷한 작업 (이메일 전송같은..) 을 하나의 `event` 로 `group` 화 시켜 처리할수 있다.

새로운 작업이 추가될때마다 `event` 가 이미 등록되어 있는지 혹은 현재 실행되고 있는지 확인하지 않고, 모든 작업 (이메일 발송함의 메일을 한번에 전송) 을 처리하는 동기화 이벤트를 추가할수 있다.

다음은 이메일 서비스를 구현하는 시나리오이다.

1. 사용자가 이메일을 보낼때 마다, `IndexedDB` 의 보낸 편지함에 이메일을 저장한다.
2. 그와 동시에 `send-un-send-message`  를 `BackgroundSync` 이벤트를 등록하고 구현할수 있다.
3. `service worker` 쪽의 `event listener` 는 `IndexedDB` 의 보낸편지함의 모든 이메일을 순회하며, 이메일 전송을 시도한다.
4. 발송에 성공하면, 해당 이메일을 삭제한다.
5. 발송에 실패하면, 이 이메일은 `sync` 이벤트에서 `reject` 된다.
6. `SyncManager`  는 사용자의 네트워크 환경이 바뀌거나 일정 시간이 지난 경우, 다시 이벤트를 발생시킨다.
7. 다시한번 `IndexedDB` 의 보낸 편지함을 돌며, 전송되지 않은 이메일과 그 이후에 새로 작성한 이메일을 다시 발송하고, 보낸 편지함을 비운다.
8. 반복한다.

이는 보낸 편지함에 이메일이 있는 한, 동기화 이벤트는 등록된 상태를 유지하며, 주기적으로 해당 이메일을 전송하려고 시도한다.
