
작업을 수행하는 코드를 페이지에서 서비스 워커로 옮기면, 무슨일이 있어도 작업이 수행되도록 만들 수 있다.

하지만 이로인한 새로운 복잡성이 생겨난다.
대부분의 경우 페이지에서 수행되는 작업을 완료되기 위해서는 데이터가 필요하다.

포스팅에 `"좋아요"` 를 누르는 함수는 포스팅의 `ID` 가 필요하다.
하지만 동기화 이벤트를 등록할때는 이벤트 이름만 전달할수 있다.

다시말해 `background` 에서 `message` 를 전송하도록 `service worker` 에 요청할수는 있지만, 메시지 텍스트를 전달하는 것은 함수에 인자를 전달하는것처럼 간단하지는 않다.

이를 위한 여러 방식을 고려해야 한다.

## IndexedDB 에 액션 큐 만들기

가장 이상적인 방법은 `backgroun` `sync` 작업이 시작되기 전에 사용자가 작업하고 있는 내용을 `IndexedDB` 에 저장하는 방법이다.

그후 `service worer` 의 동기화 이벤트 코드는 객체 저장소를 순회하며, 저장된 내용을 기반으로 필요한 작업을 수행한다.

작업이 성공적으로 완료되면, 해당 항목은 객체 저장소에서 삭제된다.
모든 신규 메시지를 `message-queue` 객체 저장소에 추가한 후, 백그라운드 동기화 이벤트를 처리하기 위한 `send-message` 이벤트를 등록해야 한다.

이 이벤트는 `message-queue` 의 모든 메시지를 순회하여, 각 메시지를 네트워크로 전송하고 `message-queue` 에서 삭제한다.

모든 메시지가 전송되고 겍체 저장소가 비워진 후에 `sync` 이벤트가 성공적으로 리졸브된다.
메시지 하나라도 전송에 실패하면, `reject` 된 프로미스가 이벤트로 반환되고, `SyncManager` 는 차후에 다시 동기화 이벤트를 시작한다.

필요한 `queue` 마다 별개의 객체 저장소를 유지하여, 각각을 처리하는 별도의 동기화 이벤트를 만들수 있다.

>[!info] message page
```js
const triggerMessageQueueUpdate = () => {
	navigator.serviceWorker.ready.then((registration) => {
		registration.sync.register("message-queue-sync");	
	});
};

const sendMessage = (subject, message) => {
	fetch("/new-message", {
		method: "post",
		body: JSON,stringify({
			subj: subject, 
			msg: message
		})
	});
	triggerMessageQueueUpdate();
};
```

>[!info] service worker
```js
self.addEventListener("sync", (event) => {
	if (event.tag === "message-queue-sync") {
		event.waitUntil(() => {
			return getAllMessages().then((messages) => {
				return Promise.all(
					messages.map((message) => {
						return fetch("/new-message", {
							method: "post",
							body: JSON.stringify({
								subj: subject,
								msg: message
							})
						});
					})
				);
			});
		});
	}
});
```
