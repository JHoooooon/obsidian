
`Page` 로드시 `Service Worker` 의 `code` 가 페이지를 관리하지 못하는 것 처럼 보이고, 페이지를 여러번 새로고침 해야 했던 경험이 있을 것이다.

`Service Worker` 코드를 변경하고 새로고침했지만, 변경되지 않는 경우도 존재한다.

이를 해결하기 위해 페이지가 새로고침될때 마다 `Service Worker` 에 변경사항이 있는지 알수 있는 `Update on reload` 모드를 사요할수 있지만, 권장하지는 않는다.

이는 `cheat key` 같은 것으로, 새로고침해야 하는 문제를 해결해주지만, `service` 사용자에게 권장할수 있는 방법은 아니다.

 `Service Worker` 의 특성을 처음 접할때 혼란스러울수 있다.
 이는 `Service Worker` 의 생명주기와 연관되어 있어, 알게되면 명확하게 이해할수 있다.
## 서비스 워커의 생명주기

`page` 가 새로운 서비스워커를 등록하려면 여러 단계의 상태를 거쳐야 한다.

![[Service worker lifecycle.png]]

### Installing

`navigator.serviceWorker.register` 를 사용하여 `service worker` 를 등록할 때, `javascript` 가 다운로드 되고 `parsing` 이 끝나면, `service worker` 는 `installing` 상태에 들어선다.  

`installing` 이 완료되면, `installed` 상태로 변하게 된다.
만약 `error` 가 `throw` 되면, `page` 를 `refresh` 하여 `service worker` 를 다시 등록하거나, `Redundant` (`더이상 사용하지 않는`) 상태로 존재한다. 

>[!info] Redundant (중복)
>이는 `service worker` 는 더이상 클라이언트 요청을 처리하지 않으며, 서비스가 중단되 상태임을 말한다.<br><br>이는 `service worker` 가 더이상 유효하지 않는다는 신호이다.<br><br>책에서는 `중복` 이라고 쓰는데, 이상하다. 이는 `불필요한 상태` 혹은 `더 이상 사용되지 않는 상태`  로의 뜻으로 쓰이는게 덜 헷갈리겠다.

`waitUntil` 을 호출하면, `Installing` 상태를 `Promise` 가 `settled` 될때 까지, 상태는 변경되지 않고 여전히 `Installing` 상태를 유지한다.

`Promise` 가 `Resolve` 되면, `Installed` 상태로, `Reject` 되면 `Redundant` 상태가 된다.

### Installed/Waiting

`service worker` 가 성공적으로 `install` 되면, `installed` 상태로 넘어간다.

현재 `activate` 되어 있는 다른 `service worker` 가 `app` 을 제어하고 있지 않으면, 바로 `activating` 상태로 전환된다.

앱을 제어 하고 있는경우 `waiting` 상태가 유지된다.

### Activating

`service worker` 가 `Activate` 되어 `app` 을 제어하기 전, `activate` `event` 가 발생한다. 

`installing` 상태와 비슷하게, `Activating` 상태 또한 `event.waitUntil()` 을 호출하여 `Promise` 가 `Settled` 될때까지 유지된다.

### Activated

`service worker` 가 `Activate` 되면, `Page` 를 제어하고 `fetch` 이벤트와 같은 동작 이벤트를 받을 준비가 된다.

`service worker` 는 `page` `loading` 이 시작되기 전에만 `page` 제어 권한을 가져올 수 있다.
즉, `service worker` 가 `activate` 되기 전에 `loading` 이 시작된 페이지는 `service worker` 가 제어할수 없다.

### Redundant

`service worker` 가 `registrating`, `installing` 에서 실패하거나, 새로운 버전으로 교체되면 `redundant` 상태가 된다.

이 상태의 `service worker` 는 `app` 에 아무런 영향을 미치지 못한다.

>[!warning] `service worker` 와 `service worker` 의 `state` 는 개별 브라우저의 `tap` 의 영향을 받지 않는다.<br><br>`activated` 상태에 들어간 `service worker` 가 이미 존재하면, 사용자가 다른 탭을 열러 똑같은 `service worker` 를 `registation` 을 요청하는 경우에도 `service worker` 는 같은 상태를 유지한다.<br><br>`page` 가 이미 `activated` 상태의 `service worker` 를 요청하는 경우, `browser` 는 이를 감지하여 `service worker` 를 다시 설치하지 않는다.

---

다음은 `sw.js` 의 내용이다.

```js
// install event
self.addEventListener("install", () => {
	console.log("install");
});

// activate event
self.addEventListener("activate", () => {
	console.log("activate");
});

self.addEventListener("fetch", (event) => {
	if (event.request.url.includes("bootstrap.min.css")) {
		console.log(`Fetch request for: ${event.request.url}`);
		event.respondWith(
			new Response(
				`.hotel-slogan { background: green!important; }
				 nav { display: none }`,
				{ headers: { "Content-Type": "text/css" } }
			)
		);
	}
});
```

여기에서, 사용자가 처음 방문하면, `app` 은 `service worker` 를 등록한다.

이때, `service worker` 파일이 다운로드 되면서, `install` `event` 가 발생하고, `console` 에 `"install"` 이 출력된다. 

`service worker` 는 `installed` 상태로 들어서고, 그 즉시 `activating` 상태가 된다.
`activate` `event` 에 의한 함수가 호출되어 `console` 에 `"activate"` 를 출력한다.

처리가 완료되면, `activated` 상태로 들어가며, `service worker` 는 `activated` 이므로, `page` 를 제어할 준비가 된다.

`service worker` 의 `installing` 과 `activate` 는 `page` 의 `loading` 과 `rendering` 과 별개로 진행된다. 

이말은, `page` `loading` 및 `rendering` 되는 동안 `service worker` 가 `install` 되거나 `activate` 될수 있수 있다는 것이다.

이렇게 `service worker` 가 `activate` 되기 전에, `page` 가 `loading`  및 `rendering` 되는 경우, [[#Activated]] 에 명시한 대로, `page` 의 제어 권한을 가져올 수 없으며, `activated` 상태로써 대기한다.

>[!info] 이럴때, `page` 는 `redering` 완료 이후 `service worker` 가 `activate` 상태가 되었다면, 여전히 `activated` 상태이며, 페이지 로딩 및 렌더링에 영향을 미치지 않는다.<br><br>`redundant` 가 아니다. 혹시나 이러한 경우 `redundant` 일까 생각이 들어서 추가로 내용을 남긴다.

이후 새로고침 하는순간 `activated` 상태가 되며, `page` 역시 제어 가능하고, `fetch` 이벤트를 수신하고 실행할수 있다.

## 서비스 워커의 수명과 waitUntil 의 중요성

`service worker` 가 성공적으로 설치되고 활성화 되었다면, `service worker` 가 `browser` `tab` 이나 `window` 창에 직접 묶여있지 않고, 언제든 이벤트에 응답할수 있다.

>[!warning] `browser` 가 현재 등록한 `service worker` 를 항상 실행상태로 두는가?
>`service worker` 의 수명은 `service worker` 가 처리하는 이벤트와 직접적으로 연괸되며, `service worder` 범위 내에서 이벤트가 발생한다면, `service worker` 는 `activated` 되고 `event` 를 처리한 후 종료된다. 
>
>이는 사용자가 사이트 방문시, `service worker` 가 시작되고, `page` 에서 `event` 처리가 완료된후 즉시 종료된다.
>
>그후, 다른 `event` 가 나중에 들어온다면, `service worker` 는 다시 시작되고, 완료되는 즉시 종료될것이다.

만약 `service worker` 가 `handler` 코드에서 비동기적으로 호출되면 어떻게 될까? 

```js
self.addEventListener('push', async () => {
	const res = await fetch("/updates");
	self.registration.showNotification(res.text());
});
```

이는 `push` `event` 가 발생하면, 서버로 부터 업데이트를 가져오기 위해 시도하고, 응답을 받게 되면 업데이트를 사용자에게 알린다.

하지만, 이코드는 비동기적으로 움직인다.
비동기적이라면, `callback` 함수의 `fetch` 함수가 실행되기 전에, `event listener` 가 종료된다. 

>[!info] `javascript` 의 `async` 는 `background` 로 `callback` 함수를 보내며 실행이 완료된다음, `task queue` 로 보낸다. <br><br>`event loop` 는 `callstack` 의 함수가 전부 비워진후, 더이상 실행할 함수가 존재하지 않을때,**(이는 비동기 작업을 제외한 동기적 작업이 완료된 이후이다. 그러므로, `service worker` 는 종료된 상태가 된다.)** `task queue` 의 함수를 실행한다.<br><br>이는 `fetch` 함수가 비동기이므로, 기존의 `event listener` 는 종료되며, 이후의 코드는 실행된다. 

이후, `fetch` 요청을 받기 전에, `browser` 의 `service worker` 는 종료되며, `fetch` 의 응답을 처리하고 업데이트를 표시할 주체역시 사라진다.

이때, `service worker` 가 종료되지 않도록 해주는 메서드가 `waitUntil` 이다.

이는 `waitUntil` 을 사용해서 필요한 작업이 완료될때 까지 `event listener` 의 실행을 유지하며, `service worker` 가 종료되는 것을 방지한다. 

다음은, `header` 의 배경 색상을 `green` 에서 `red` 로 변경한다.
즉, `service worker` 를 업데이트한것이다.

```js
self.addEventListener('push', (event) => {
	event.waitUntil(
		fetch("/updates").then((res) => {
			self.registration.showNotification(res.text());
		})
	)
});

self.addEventListener("fetch", (event) => {
	if (event.request.url.includes("bootstrap.min,css")) {
		console.log(`Fetch request for: ${event.request.url}`);
		event.respondWith(
			new Response(
				`.hotel-slogan { background: red!important } 
				nav { display: none }`,
				{ headers: { "Content-Type": "text/css" } }
			)
		);
	}
});
```

페이지를 새로그침해도 반영되지 않고 배경도 여전히 `green` 이다.
이는, `service worker` 가 `2개` 등록되어 있지만, 그 중 하나인 `service worker` 가 `page` 를 제어하고 있다.

>[!info] 이전의 `service worker` 는 `green` 이며, 이후 변경한 `service worker` 는 `red` 로 변경한것이다. 즉, 페이지에는 `2개의 service worker` 가 등록되어 있으며, 그중 앞전의 `service worker` 가 활성화 되어있는 상태이다.

`chorme devtool` 에서 보면 이후에 등록한 `service worker` 는 `wait` 중임을 알수있다.

이는 `activated` `service worker` 와 함께 `page` 가 `load` 되면, `service worker` `script` 에 대한 `update` 가 있는지 확인한다. 

`service worker` 가 등록된 이후 `file` 이 변경되면, 새 `file` 이 등록되고, `install` 된다.
`installed` 면, 새로운 `service worker` 는 기존의 `service worker` 로 바로 교체되지 않고 `wait` 상태로 남게 된다.

`browser` 의 모든 `tap` 과 `window` 창이 종료되거나, 범위를 벗어난 새로운 `page` 로 이동할때 까지, 새로운 `service worker` 는 `wait` 상태를 유지한다.

기존의 `activated` `service worker` 가 제어하는 `page` 가 더이상 열려 있지 않다면, 기존의 `activated` `service worker` 는 `redundant` 상태가 되고, 새로운 `service worker` 가 `activated` 된다.

### 캐시를 관리해야 하는 이유

그럼 `off-line` 홈페이지의 컨텐츠를 변경하기로 했다고 가정하자.

`sw-index.html` 이 업데이트 되었다면, `service worker` 가 새 버전의 파일을 내려받고 `CacheStorage` 에 저장해야 한다는것을 알려주어야 한다.

다음은 기존의 로직이다.

```js
const CACHE_NAME = 'gih-cache';
const CACHED_URLS = [
	"/index-offline.html",
	"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css",
	"/css/gih-offline.css",
	"/img/jumbo-background-sm.jpg",
	"/img/logo-header.png"
];

self.addEventListener("install", (event) => {
	event.waitUntil(
		caches.open(CACHE_NAME).then((cache) => cache.addAll(CACHED_URLS));
	);
});

self.addEventListener("fetch", (event) => {
	event.repondWith(
		fetch(event.request).catch(async () => {
			const res = caches.match(event.request);
			if (res) {
				return res;
			} else if (event.request.headers.get("accept").includes("text/html")) {
				return caches.match("/index-offline.html");
			}
		})
	);
})
```

여기에서, 버전명을 변경하여 처리한다.

>[!info] 보통 버전명을 사용하여, 서비스 워커를 반영한다.<br><br>이는 버전명이 변경됨으로써 `activate` `service worker` 를 새로운 `wait` 상태의 `service worker` 로 변경되어야 하는것을 알수 있도록 한다.

```js
const CACHE_NAME = "gih-cache-v2";
```

변경사항이 서비스 워커 파일에 반영되면, `browser` 는 `activated` `service worker` 를 새로운 `service worker` 로 바꾸어 `install` 해야 함을 알게된다.

이를 통해 새 파일을 내려받고, `cache` 에 저장되도록 새 `install` `event` 를 발생시킨다.

하지만, 앞의 `lifecycle` 에 의하면, `cache` 가 이미 `update` 되었더라도, 사용자가 열려있는 모든 `page` 를 닫기 전까지는 기존 `activated` `service worker` 가 활성화 되어 있다.

새로운 `service worker` 는 `wait` 중이며, 이러한 작동을 통해 각 버전의 `cache` 를 가지고 있음으로써 예상치 못한 오류를 방지할수 있다.

## 캐시 관리 및 이전 캐시 제거

`cache` 와 `service worker` 의 `version` 을 관리함으로써, `service worker` 의 `version` 마다 각 `version` 에 해당하는 `cache file` 에만 의존하면 되는 강력한 시스템을 구축할 수 있다.

이는 사용자에게 예기치 못한 방향으로 영향이 가지 않도록 관리할 수 있다.
`service worker` 를 `v327` 로 `update` 했더라도, 사용자는 `v122` 의 `service worker` 를 가지고 있음을 잊지 말아야 한다.

이는 매번 `cache` 를 생성한다. 이렇게 계속 `cache` 를 다시 생성하는 것은 사용자의 기기를 낭비할수 있다는 것이다.

이는 `327` 개의 동일한 사이트 로고 이미지와 `327` 개의 똑같은 고해상도 사진을 저장하는 결과가 될 수 있다.

이를 해결하기 위해 `cache` 관리 및 `cache` 제거하는 방법을 사용해야 한다.

---

**caches.delete(cacheName)**: 첫번째 인수로 캐시명을 받고 캐시를 삭제

**caches.keys()**: 접근 가능한 모든 `cache` 의 이름을 받아오는 편리한 방법, `cache` 명 배열을 `resolve` 하는 `promise` 를 반환

---

이는 다음처럼 만들수 있다.

```js
caches.keys().then((cacheNames) => {
	cacheNames.forEach((cacheName) => {
		caches.delete(cacheName);
	});
});
```

>[!info] `APP` 은 최대 `2` 개의 `cache` 를 필요로 한다.<br>만약 새로운 `service worker` 가 `update` 되었다면, `activated` `service worker` 와 `wait` `service worker` 가 존재할 것이다.<br><br>**중복된 `service worker` 에 종속되어 있는 `cache` 는 모두 필요하지 않다.** 

다음은 `service worker` 생명주기 관점으로 이를 나누어 본다.

1. 새로운 `service worker` 를 `install` 할때 마다 새로운 `cache` 를 생성한다.
2. 새로운 `service worker` 가 `activate` 되면, 이전 `service worker` 가 생성해 두었던 모든 `cache` 는 삭제하는것이 좋다.

```js
self.addEventListener("activate", (event) => {
	event.waitUntil(
		caches.keys().then((cacheNames) => {
			return Promise.all(
				cacheNames.map((cacheName) => {
					if (
						CACHE_NAME !== cacheName 
						&& cacheName.startsWith("gih-cache")
					) {
						return caches.delete(cacheName);
					}
				})
			);
		})
	);
});
```

>[!info] 여기서 `caches.delete(cacheName)` 은 `cache` 의 `data` 를 `promise object` 를 반환한다.<br>이러한 `promise object` 의 `array` 를 `map` 에서 반환하고, 이를 `promise.all` 을 통해 비동기 작업을 한다.

>[!warning] `Promise.all` 은 모든 `Promise object` 의 `state` 가 `fulfiled` 인 상태일때만 반환하며, 하나라도 `rejected` 된 경우 `{<state>: "rejected", <reason>: 44}` 처럼 `reject` 된 `promise` 가 생성된다.<br><br>이는 `Promise.all` 은 모든 `promise` 가 `fulfiled` 되어야 `resolve` 되며, 그렇지 않으면 `rejected` `promise` 가 생성된다.

## 캐싱된 response 를 다시 사용

새로운 `cache` 를 생성할때마다, `cache.add()` 나 `cache.addAll()` 을 사용하여 `app` 에 필요한 모든 파일을 `caching` 한다.

만약, `cache-v1` 의 `cache` 가 있고, `cache-v2` 를 새롭게 생성하며, `cache` 상에 절대 변하지 않는 `변하지 않는 file` 이 있다고 하자

새로운 네트워크에서 `static assets` 를 `server` 에서 받기보다는, 동적으로 변하지 않는 `file` 같은 경우 기존의 `cache-v1` 에서 가져오는것이 좋다.

>[!info] `server` 에서 `file` 을 가져오는것은, 불필요한 네트워크 통신이 이루어지며, 기존의 `local` 상에 `cache` 된 데이터를 가져오는것보다 비용이 더 클수밖에 없다.

이런 파일들이 기존 `cache` 에 있는지 검색하고, 존재한다면, `network` 에서 다시 내려받는 대신 기존 `cache` 에서 새로운 `cache` 로 직접 복제하도록 한다.

```js
const immutableRequests = {
	"/fancy_header_background.mp4",
	"/vendor/bootstrap/3.3.7/bootstrap.min.css",
}
```




