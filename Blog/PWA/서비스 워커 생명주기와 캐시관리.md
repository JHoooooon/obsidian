
`Page` 로드시 `Service Worker` 의 `code` 가 페이지를 관리하지 못하는 것 처럼 보이고, 페이지를 여러번 새로고침 해야 했던 경험이 있을 것이다.

`Service Worker` 코드를 변경하고 새로고침했지만, 변경되지 않는 경우도 존재한다.

이를 해결하기 위해 페이지가 새로고침될때 마다 `Service Worker` 에 변경사항이 있는지 알수 있는 `Update on reload` 모드를 사요할수 있지만, 권장하지는 않는다.

이는 `cheat key` 같은 것으로, 새로고침해야 하는 문제를 해결해주지만, `service` 사용자에게 권장할수 있는 방법은 아니다.

 `Service Worker` 의 특성을 처음 접할때 혼란스러울수 있다.
 이는 `Service Worker` 의 생명주기와 연관되어 있어, 알게되면 명확하게 이해할수 있다.
## 서비스 워커의 생명주기

`page` 가 새로운 서비스워커를 등록하려면 여러 단계의 상태를 거쳐야 한다.

![[Service worker lifecycle.png]]

### Installing

`navigator.serviceWorker.register` 를 사용하여 `service worker` 를 등록할 때, `javascript` 가 다운로드 되고 `parsing` 이 끝나면, `service worker` 는 `installing` 상태에 들어선다.  

`installing` 이 완료되면, `installed` 상태로 변하게 된다.
만약 `error` 가 `throw` 되면, `page` 를 `refresh` 하여 `service worker` 를 다시 등록하거나, `Redundant` (`더이상 사용하지 않는`) 상태로 존재한다. 

>[!info] Redundant (중복)
>이는 `service worker` 는 더이상 클라이언트 요청을 처리하지 않으며, 서비스가 중단되 상태임을 말한다.<br><br>이는 `service worker` 가 더이상 유효하지 않는다는 신호이다.<br><br>책에서는 `중복` 이라고 쓰는데, 이상하다. 이는 `불필요한 상태` 혹은 `더 이상 사용되지 않는 상태`  로의 뜻으로 쓰이는게 덜 헷갈리겠다.

`waitUntil` 을 호출하면, `Installing` 상태를 `Promise` 가 `settled` 될때 까지, 상태는 변경되지 않고 여전히 `Installing` 상태를 유지한다.

`Promise` 가 `Resolve` 되면, `Installed` 상태로, `Reject` 되면 `Redundant` 상태가 된다.

### Installed/Waiting

`service worker` 가 성공적으로 `install` 되면, `installed` 상태로 넘어간다.

현재 `activate` 되어 있는 다른 `service worker` 가 `app` 을 제어하고 있지 않으면, 바로 `activating` 상태로 전환된다.

앱을 제어 하고 있는경우 `waiting` 상태가 유지된다.

### Activating

`service worker` 가 `Activate` 되어 `app` 을 제어하기 전, `activate` `event` 가 발생한다. 

`installing` 상태와 비슷하게, `Activating` 상태 또한 `event.waitUntil()` 을 호출하여 `Promise` 가 `Settled` 될때까지 유지된다.

### Activated

`service worker` 가 `Activate` 되면, `Page` 를 제어하고 `fetch` 이벤트와 같은 동작 이벤트를 받을 준비가 된다.

`service worker` 는 `page` `loading` 이 시작되기 전에만 `page` 제어 권한을 가져올 수 있다.
즉, `service worker` 가 `activate` 되기 전에 `loading` 이 시작된 페이지는 `service worker` 가 제어할수 없다.

### Redundant

`service worker` 가 `registrating`, `installing` 에서 실패하거나, 새로운 버전으로 교체되면 `redundant` 상태가 된다.

이 상태의 `service worker` 는 `app` 에 아무런 영향을 미치지 못한다.

>[!warning] `service worker` 와 `service worker` 의 `state` 는 개별 브라우저의 `tap` 의 영향을 받지 않는다.<br><br>`activated` 상태에 들어간 `service worker` 가 이미 존재하면, 사용자가 다른 탭을 열러 똑같은 `service worker` 를 `registation` 을 요청하는 경우에도 `service worker` 는 같은 상태를 유지한다.<br><br>`page` 가 이미 `activated` 상태의 `service worker` 를 요청하는 경우, `browser` 는 이를 감지하여 `service worker` 를 다시 설치하지 않는다.

---

다음은 `sw.js` 의 내용이다.

```js
// install event
self.addEventListener("install", () => {
	console.log("install");
});

// activate event
self.addEventListener("activate", () => {
	console.log("activate");
});

self.addEventListener("fetch", (event) => {
	if (event.request.url.includes("bootstrap.min.css")) {
		console.log(`Fetch request for: ${event.request.url}`);
		event.respondWith(
			new Response(
				`.hotel-slogan { background: green!important; }
				 nav { display: none }`,
				{ headers: { "Content-Type": "text/css" } }
			)
		);
	}
});
```

여기에서, 사용자가 처음 방문하면, `app` 은 `service worker` 를 등록한다.

이때, `service worker` 파일이 다운로드 되면서, `install` `event` 가 발생하고, `console` 에 `"install"` 이 출력된다. 

`service worker` 는 `installed` 상태로 들어서고, 그 즉시 `activating` 상태가 된다.
`activate` `event` 에 의한 함수가 호출되어 `console` 에 `"activate"` 를 출력한다.

처리가 완료되면, `activated` 상태로 들어가며, `service worker` 는 `activated` 이므로, `page` 를 제어할 준비가 된다.

`service worker` 의 `installing` 과 `activate` 는 `page` 의 `loading` 과 `rendering` 과 별개로 진행된다. 

이말은, `page` `loading` 및 `rendering` 되는 동안 `service worker` 가 `install` 되거나 `activate` 될수 있수 있다는 것이다.

이렇게 `service worker` 가 `activate` 되기 전에, `page` 가 `loading`  및 `rendering` 되는 경우, [[#Activated]] 에 명시한 대로, `page` 의 제어 권한을 가져올 수 없으며, `activated` 상태로써 대기한다.

>[!info] 이럴때, `page` 는 `redering` 완료 이후 `service worker` 가 `activate` 상태가 되었다면, 여전히 `activated` 상태이며, 페이지 로딩 및 렌더링에 영향을 미치지 않는다.<br><br>`redundant` 가 아니다. 혹시나 이러한 경우 `redundant` 일까 생각이 들어서 추가로 내용을 남긴다.

이후 새로고침 하는순간 `activated` 상태가 되며, `page` 역시 제어 가능하고, `fetch` 이벤트를 수신하고 실행할수 있다.


