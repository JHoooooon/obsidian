
>[!info] 프로그램은 데이터를 가지고 작업한다.<br>컴퓨터는 수, 문자, 단어들을 넣어주고, 그 데이터를 가지고 컴퓨터가 어떤일을 해주기를 기대한다.

```c
#include <stdio.h>

int main(void) {
  float weight; // 몸무게
  float value; // 플래티넘 가치로 계산한 값
  printf("당신의 몸무게를 플래티넘 가치로 계산하면 얼마나 나갈까요?\n");
  printf("어디 한번 계산해 봅시다.\n");
  printf("몸무게를 파운드 단위로 입력하시오: ");
  
  // 사용자로 부터 입력을 받는다
  scanf("%f", &weight);

  // 플래티넘 가격이 온스당 $1700 이라고 가정한다.
  // 14.5833 은 상형 파운드 단위를 금형 온스 단위로 변환한다.
  value = 1700.0 * weight * 14.5833;

  printf("당신의 몸무게를 플래티넘 가치로 계산하면 $%.2f 입니다.\n", value);
  printf("당신의 몸값은 그 정도 가치가 나갑니다. 플래티넘 가격이 떨어지면, \n");
  printf("가치를 유지하기 위해 식사량을 늘려야 합니다.\n");

  return 0;
}
```

$1700,0$ 을 귀금속 플래티넘의 현 시세로 바꾸어도 상관없다.
그러나, $14.5833$ 은 $1$ 파운드에 해당하는 온스 수를 나타내는 것이므로 절대 손대지 말아야 한다.

>[!info] 귀금속에 쓰이는 금형단위로 온스를 사용하며, 귀금속:LiDot:보석:LiDot: 약품을 제외한 모든것에 쓰이는 상형 단위이다. 

여기에는 여러가지, 데이터 타입이 사용되었다.
이를 이해하기 위해 변수와 상수를 알아보자

## 변수와 상수

컴퓨터는 프로그램의 안내를 받아 많은 일들을 할수 있다.
많은 일들을 하려면, 프로그램은 정보를 담고있는 수와 문자들, `data` 를 가지고 작업해야 한다.

어떠한 미리 정해져있으며, 그 값이 변하지 않는 값이라면 이는 `상수`(`constant`) 라 한다.
반면, 값이 정해져 있지 않으며, 그 값이 변하는 값이라면 이는 `변수`(`variable`) 이라 한다.

여기서, `weight` 은 `변수` 이고, $14.5833$ 은 상수이다.

## 데이터 형을 나타내는 키워드

>[!info] 변수와 상수를 구분하는 외에도 서로 다른 종류의 데이터를 구분해야 한다.<br>컴퓨터는 서로 다룬 종류의 데이터를 인식하고 사용할수 있는 방법이 필요하다.<br>`C` 는 이를 위해 기본적인 데이터 형을 인식한다.

데이터형을 나타내는 키워드는 선언문을 통해서 알려준다.
`C` 가 인식하는 기본적인 데이터형들이 존재하는데, `K&R` 의 `C` 는 데이터형과 관련하여 총 $7$ 개의 키워드를 인식하며, `C90` 표준은 여기에 $2$ 개를 더 추가한다.

`C99` 표준은 여기에 또다른 $3$ 개를 추가했다

| K&R C keyword | C90 K&R keyword | C99 keyword |
| :------------ | --------------- | ----------- |
| int           | signed          | \_Bool      |
| long          | void            | \_Complex   |
| short         |                 | \_Imaginary |
| unsigned      |                 |             |
| char          |                 |             |
| float         |                 |             |
| double        |                 |             |
`C90` 에서 제공하는 `signed` 키워드는 기본형의 변형을 제공하기 위해 사용된다.

`C99` 의 `_Bool` 형은 `boolean` 값을 나타내는대 사용되며, `_Complex` 와 `_Imagenary` 는 복소수와 허수를 나타내는데 사용된다.

>[!note] 비트, 바이트, 워드
>
>비트, 바이트, 워드는 컴퓨터의 데이터 단위로 표시하는데 사용된다.
>
>**메모리의 가장 작은 단위를 `bit` 라 한다.**
>비트는 $0$ 또는 $1$ 두값중 하나만 저장할수 있다.
>
>**바이트는 컴퓨터 메모리의 통상적인 단위이다.**
>거의 모든 컴퓨터에서 $1$ 바이트는 $8$ 비트다.
>이는 $2^8 = 256$ 의 비트 패턴을 나타낸다.
>이러한 비트 패턴을 이용하여, 문자 집합을 각 정수값과 매핑시켜 만들어진것이 `ASCII` 코드이다.
>
>**워드는 컴퓨터 설계할때 정해지는 고유 메모리 단위이다.**
>만약 `Apple 컴퓨터` 와 `8bit micro 컴퓨터` 에서 워드는 $8$ 비트이다.
>하지만 그 이후로, 퍼스널 컴퓨터들은 $16$비트 워드, $32$ 비트 워드, 현재는 $64$비트 워드까지 발전했다.
>
>더큰 워드 크기는 데이터를 더빠르게 옮길수 있으며, 더 많은 메모리에 접근 가능하다.

### 정수형과 부동소수점형

#### 정수 

정수는 소수부가 없는 수이다.
`C 언어` 에서 정수는 소수점이 있는 형태로 적을수 없다.

$2,\;-23,\;2456$ 은 정수이며, $3.14,\;0.22,\;2.000$ 은 실수이다. 
정수는 $2$ 진수 형태로 저장된다.

이는 정수 $7$ 을 $8$ 비트 워드에 저장하면 다음과 같은 모습이다

| 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   |
| :-- | --- | --- | --- | --- | --- | --- | --- |

#### 부동소수점

부동소수점은 실수와 비슷하다.
실수는 정수와 정수 사이에 들어있는 모든 수를 포함한다.

>[!info] 실수
$$2.75,\;3.16E7,\;7.00,\;2e-8$$

어떠한 값에 소수점을 붙이면, 부동소수점 값이 된다
만얀 $7$ 은 정수이지만, $7.00$ 은 부동소수점이다.

부동소수점 수를 표기하는 방법은 여러가지가 있으며, $e-$ 표기가 존재한다.
$3.16E7$ 은 $3.16$ 에 $10$ 의 $7$ 승을 곱한수이다.

$7$ 을 $10$ 의 `지수`(`exponent`) 라 부른다.

부동소수점은 하나의 수를 `소수부`(`fractional part`) 와 `지수부`(`exponent part`) 로 쪼개서 저장한다.
값은 같더라도 부동소수점은 $7.00$ 은 정수 $7$ 과 같은 방식으로 저장되지 않는다.

$7.0$ 은 $0.7E1$ 로 적을수 있다.
여기서 **$0.7$ 이 소수부**이고, **$1$ 이 지수부**이다.

부동소수점은 다음처럼 정리가 가능하다.

- 부동소수점 수는 **정수부보다 훨씬 큰 범위의 수**를 나타낼수 있다.
- **매우 큰수에서 다른 큰수를 빼는것과 같은 일부 산술 연산에서, 부동소수점 수는 더큰 정밀도 손실**을 입을수 있다.
- **어떤 범위에 들어있는 실수의 수는 무한하기 때문에, 컴퓨터는 그 범위에 있는 모든 값들을 부동소수점으로 나타낼수 없다.** (ex: 1.0 과 2.0 사이의 수)<br>그러므로 **부동소수점 값들은 실제 값들의 근사값**이다. (ex: $7.0$ 은 $6.99999$ float 값으로 저장될수 있다.)
- 일반적으로 부동소수점 수 연산은 정수 연산보다 느리다.<br>그러나 오늘날 `CPU` 는 그 속도의 차이를 극복하는 부동소수점 프로세스를 채용하고 있다.

### C 의 기본 데이터형

#### int 형

`C` 는 다양한 정수형을 제공한다.
`C` 의 정수형들은 제공되는 값의 범위와 음수가 사용되느냐에 따라 달라진다.

`int` 형이 기본 선택이지만, 특정 과업이나 컴퓨터의 요구에 따라 다른 선택을 해야 하는 경우도 있다. 
`int`형은 기본적으로 `signed` 정수이다.

허용되는 값의 범위는 컴퓨터시스템에 따라 다르다.

`int` 는 컴퓨터의 $1$ 워드로 저장된다.
>[!info] 오늘날에서의 컴퓨터는 $64$ 비트 컴퓨터이므로, $1$ 워드는 $64$ 비트라고 생각할수 있다.<br> `ISO C` 에서 `int` 의 최소 범위를 $-32767 ~ 32767$  로 규정한다.<br> 

>[!warning] 이 부분이 약가 애매한데, 현재 내 컴퓨터가 $64$ 비트 컴퓨터인데, `int` 가 $4$ 바이트로 표시된다.<br><br>이는 따로 설정하는 부분이 있는지 모르겠지만, 일단은, $1$ 워드로 처리되지만, $4$ 바이트라고 알고 있자...<br>분명 이후 설명이 나올것이다..

`printf` 함수에서 `int` 형 값을 출력할때, `%d` 포맷 지정자를 사용한다.
`int` 는 $8$ 진수, $16$ 진수로도 표현가능하다.

$8$ 진수는 접두사로 `0`, $16$ 진수는 접두사로 `0x`  를 사용한다.
이때, $8$ 진수로 정수를 출력한다면 `%o` 포맷지정자를, $16$ 진수는 `%x` 를 사용한다.

만약 앞의 접두사도 함께 출력하고 싶다면, `%#o` 혹은 `%#x`, `%#X` 지정자를 사용한다.

```c
#include <stdio.h>

int main(void) 
{
  int x = 100;
  
  printf("10진수 = %d, 8진수 = %o, 16진수 = %x\n", x, x, x);
  printf("10진수 = %d, 8진수 = %#o, 16진수 = %#x\n", x, x, x);
  
  return 0;
}
```

```sh
10진수 = 100, 8진수 = 144, 16진수 = 64
10진수 = 100, 8진수 = 0144, 16진수 = 0x64
```

다음은 정수의 종류들이다.

>[!info] `signed integer` 는 부호가 포함되기에, `-` 부호의 `integer` 는 $bit 의 개수 / 2$ 숫자를 가지며, `+`  부호의 `integer` 는 $bit 의 개수 / 2 - 1$ 의 숫자까지 표현가능하다<br><br>`+` 부호에서 $-1$ 한 이유는 $0$ 을 포함하기 때문이다.

>[!info] `unsigned integer` 는 부호가 포함되지 않는다. 그러므로 `unsgined integer` 는 $bit 의 개수 - 1$ 의 숫자까지 표현가능하다<br><br>`+` 부호에서 $-1$ 한 이유는 $0$ 을 포함하기 때문이다.

- **(unsinged / signed) short int**: $16$ bit 정수형
- **(unsingend / signed) int**: $1$ word 정수형
- **(unsingend / signed) long int**: $32$ bit 정수형
- **(unsingend / signed) long long int**: $64$ bit 정수형

`long` 형과 `short` 형이 `int` 형보다 더 많거나 적은 기억공간을 사용할수도 있다.
이는 **`short` 형이 `int` 형보다 길지않고, `long` 형이 `int` 형보다 작지 않다는것을 보장하기 때문이다**.

이는 앞에서 `int` 형이 $1$ 워드와 같은것과 연관된다.

기본적으로 `C` 는 아주 오래전부터 있던 언어이다.
`C` 는 컴퓨터의 발전과 함께 데이터형이 새로 추가되거나 수정되는 부분이 많았다.

>[!note] 책에서는 다음처럼 말한다.
>
`Window 3` 를 사용하던 시절에 `int` 형과 `short` 형은 둘다 $16$ 비트였다.
하지만, `Window` 와 `Apple` 은 `short` 형이 $16$ 비트로, `int` 형과 `long` 형은 $32$ 비트로 이전한다.
$32$ 비트를 사용하면서 $20$억개의 큰 정수값을 표현할수 있게 된다.
>
>이후 $64$ 비트 프로세서가 보급되었고, 이로인해 $64$ 비트 정수형에 대한 필요성이 대두되면서, `long long` 타입이 만들어진다.

이는 오늘날 $64$ 비트 컴퓨터에서는 `long` 형은 $32$ 비트, `short` 형은 $16$ 비트로 되며, `int`는 시스템의 고유 `word` 에 따라 그 값이 $16$ ~ $32$ 비트로 설정된다.

>[!info] 원칙적으로, 이러한 데이터형은 구별되는 크기를 가져야 하지만, 실제적으로 일부 데이터형이 서로 겹친다..

이렇게 겹친 데이터형을 `C` 표준에서는, 최소 허용 크기를 정하는 가이드라인을 제공한다.

$16$ 비트 단위에 해당하는 `short` 형과 `int` 형의 최소 범위는 둘 다 $-32,767 \sim 32,767$ 까지이다.
`unsigned short / int`  는 $0 \sim 65,535$ 까지이다. 

$32$ 비트 단위에 해당하는 `long` 형의 최소 범위는 $-2,147,483,647 \sim 2,147,483,647$ 까지이다.
`unsigned long`  은 $0 \sim 4,294,976,295$ 까지이다. 

$64$ 비트 단위에 해당하는 `long long` 의 최소 범위는 생략한다..

>[!warning] 책에서는 `long` 형이 `int` 형으로는 다룰수 없는 큰수를 다룰때 사용한다고 말한다.<br>이는 `long` 형이 `int` 형보다 큰 시스템에서 사용될때, `long` 형을 사용하면 계산이 더 느려질것이라 경고한다.<br><br>(사실 현시점에서는 큰 문제는 없어보이지만...) $32$ 비트 정수들이 필요한데 $16$ 비트 시스템으로 옮겼을때 제대로 동작하기를 원한다면 `long` 형을 사용해야 한다고 말한다.

일반적으로 `메모리 공간` 의 절약은 프로그램이 사용할수 잇는 메모리와 관련하여 덩치가 큰 정수들의 배열을 사용할때 중요해진다고 말한다.

>[!info] 오버플로
>정수형의 오버플로가 일어나면, 해당 정수형의 최소값으로 넘어간다.

#### long 형 상수와 long long 형 상수

일반적으로 $2354$ 를 사용하면 `int`형으로 저장된다.
하지만, 만약 `int` 형으로 저장할수 없는 수를 상수로 저장한다면 어떻게 될까?

이럴경우 컴파일러는 `long int` 형이 충분히 크다고 가정하고, 그 수를 `long int` 형으로 취급한다.

만약 그수가 `long` 형보다 그면 그때 `unsigned long` 형으로 취급하고, 그래도 안된다면 `long long` 형으로, 그래도 안된다면 `unsigned long long` 형을 사용한다.

$8$ 진수와 $16$ 진수 상수들은 그 값이 너무 크지 않다면 `int` 형으로 취급한다.
이것으로 불충분하면 `unsigned int` 로, 그래도 안된다면 `long`, `unsigned long`, `long long`, `unsigned long long` 순으로 취급하게 된다.

만약, 작은 숫자를 `long` 형으로 취급하고 싶다면, `l` 또는 `L` 접미사를 붙인다.
`unsigned long` 형은 `ul`, `UL` 접미사를 붙인다.

작은 숫자를 `long long` 형으로 취급하고 싶다면, `ll` 혹은 `LL` 접미사를 붙인다.
`unsigned long` 형은 `llu`, `LLU` 접미사를 붙인다.

 $8$ 진수와 $16$  진수도 위의 접미사를 붙혀 작은수자를 `long`, `long long` 형으로 취급할수 있다.

#### short, long, long long, unsigned 형의 출력

- `short` 형은 `%hd` 표기를 사용 
- `unsigned short` 형은 `%hu` 표기를 사용 
- `short` 값을 $8$ 진수로 나타내려면  `%ho` 표기를 사용 
- `short` 값을 $16$ 진수로 나타내려면  `%hx` 표기를 사용 
- `unsigned int` 형은 `%u` 표기를 사용
- `long` 값은 `%ld` 표기를 사용
- `unsigned long` 값은 `%lu` 표기를 사용

>[!info] `int` 와 `long` 값이 같다면 `%d` 표기 사용가능하다<br><br>하지만, 다른 시스템으로 옮겼을때, `int` 값의 범위가 변경될수 있으므로, `%ld` 를 권장한다.

- `long` 값을 $8$ 진수로 나타내려면 `%lo` 표기를 사용
- `long` 값을 $16$ 진수로 나타내려면 `%lx` 표기를 사용
- `long long` 값은 `%lld` 표기를 사용
- `unsigned long long` 값은 `%llu` 표기를 사용
- `long long` 값을 $8$ 진수로 나타내려면 `%llo` 표기를 사용
- `long long` 값을 $16$ 진수로 나타내려면 `%llx` 표기를 사용

#### char 형

>[!info]  `char` 는 정수이다.
>
 `char` 형은 실제 문자를 저장하지 않고, 정수들을 저장하며 해당 정수값이 어떠한 문자와 매핑되었는지 찾는다.






 






