
>[!note] 트랜잭션 내에 하나 이상의 세이브 포인트를 설정하고, 이를 사용해서 트랜잭션 시작 시점으로 완전히 롤백하는 대신 트랜잭션내의 특정 위치로 롤백가능하다

---

스토리지 엔진에 대해서 볼 필요가 있다.

`MySQL`  은 리소스 잠금과 트랜잭션 관리를 포함한 낮은 수준의데이터베이스 기능을 제공하기 위해 스토리지 엔진을 활용할 수있도록 설계되었다.

- **MyISAM**: 테이블 잠금을 사용하는 넌트랜잭션 엔진

- **MEMORY**: 인메모리 테이블을 사용하는 넌트랜잭션 엔진

- **CSV**: 데이터를 쉼표로 구분해서 파일에 저장하는 트랜잭션 엔진

- **InnoDB**: 행 수준 잠금을 사용하는 트랜잭션 엔진

- **Merge**: 여러개의 `MyISAM` 테이블을 단일 테이블로 표시하는 특수 엔진 (테이블 분할)

- **Archive**: 주로 보관 목적으로 대량의 인덱싱되지 않은 데이터를 저장하는 특수 엔진

`MySQL` 은 테이블별로 스토리지 엔진을 선택할수 있을 만큼 유연한다.

**하지만, 보통은 행 수준 잠금과 버전 관리를 제공하며 최고 수준의 동시성을 제공하는 `InnoDB` 엔진을 선택한다.**

다음과 같이 `table` 에서 사용하는 엔진을 확인할수 있다

```mysql
SHOW TABLE status LIKE 'customer';
```

```sh
Name    |Engine|Version|Row_format|Rows|
--------+------+-------+----------+----+
customer|InnoDB|     10|Dynamic   | 599|
```

엔진을 변경하고 싶다면 다음처럼 가능하다

```mysql
ALTER TABLE customer ENGINE=INNODB;
```

---

모든 세이브 포인트는 이름으로 지정되며, 단일 트랜잭션 내에서 세이브 포인트를 가질 수 있다.

```mysql
SAVEPOINT my_savepoint;
```

다음은 특정 세이브포인트로 롤백한다.

```mysql
ROLLBACK TO SAVEPOINT my_savepoint;
```

이는 다음처럼 사용가능하다

```mysql
START TRANSACTION;

UPDATE product
SET date_retired = CURRENT_TIMESTAMP()
WHERE product_cd = 'XYZ';

SAVEPOINT before_close_accounts;

UPDATE account
SET
	status = 'CLOSE',
	close_date = CURRENT_TIMESTAMP(),
	last_activity_date = CURRENT_TIMESTAMP()
WHERE product_cd = 'XYZ';

ROLLBACK TO SAVEPOINT before_close_accounts;

COMMIT;
```

이는 `product` 는 `update` 하지만, `account` 는 `rollback` 된다.

이는 다음의 주의사항을 알아야 한다.

- 이름을 지정했음에도 세이브포인트를 생성하면 아무것도 저장되지 않는다. 트랜잭션을 영구저장하려면 `COMMIT` 을 실행해야 한다.

- 세이브포인트의 이름을 지정하지 않고 `ROLLBACK` 을 실행하면 트랜잭션 내의 모든 세이브포인트가 무시되고 트랜잭션이 실행 취소된다.

