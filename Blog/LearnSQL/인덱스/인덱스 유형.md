
인덱스 유형은 여러개가 존재한다. 다양한 유형의 인덱스를 살펴본다

## B-트리 인덱스

지금까지 표시된 모든 인덱스는 `B-트리 인덱스` 로 잘 알려진 `균형 트리 인덱스` 이다.

`B-트리 인덱스` 는 `leaf node` 와 하나 이상의 `branch node` 레벨이 있는 트리로 구성된다.

`branch node` 는 트리 탐색에 사용되는 반면 `leaf node` 는 실제 값과 위치 정보를 가진다.

이는 `root node` 부터 시작해서, `branch node` 의 링크를따라 가서 해당 타겟으로 삼은 `leaf node` 로 가는 방식이다.

이러한 `B-트리 인덱스` 는 `root node` 의 한쪽에 있는 `leaf/branch node` 가 다른쪽보다 더 많아지지 않도록 트리의 균형을 유지하려 한다.

이를 통해 `branch node` 를 제거/추가 함으로써 여러 레벨의 `branch node` 탐색할 필요 없이 원하는 값을 찾기 위해 `leaf node` 로 이동할수 있게 된다.

## 비트맵 인덱스

`B-트리 인덱스` 는 고객의 이름이나 성 등 다양한 값이 포함된 열을 처리하는데 탁월하지만, 소수의 값만 허용하는 열에 대해 생성하면 통제하기 어려울 수 있다.

`customer` 의 `active` 열에 인덱스를 생성하기로 해보자.

두개의 값 `1` 과 `0` 만 있고 활성 고객수가 훨씬 많은 만큼, 고객수가 증가함에 따라 균형잡힌 `B-트리 인덱스` 를 유지하기 어려울수 있다.

다수의 행에 걸쳐 적은 수의 값만 포함하는 열(`기수가 낮은` `low-cardinary` 데이터) 의 경우 다른 인덱스가 필요하다

이러한 상황을 더 효율적으로 처리하기 위해 `비트맵 인덱스` 가 있다.

인덱스는 두개의 비트맵 만 유지하며, 하는 값 `0` 에 대한 비트맵과 `1` 에대한 비트맵을 통해 원하는 행을 빠르게 검색한다,

```mysql
CREATE BITMAP INDEX idx_active ON customer (active);
```

>[!warning] 이는 `Oracle` 에서만 유효한듯 싶다.

## 텍스트 인덱스

데이터베이스에 문서가 저장된 경우 사용자가 해당 문서에서 단어나 구문을 검색하도록 지원해야 할수도 있다.

문서를 읽고 원하는 텍스트를 스캔하기를 바라지는 않겠지만, 기존의 인덱스들은 이 요건에 적합하지 않다.

이러한 상황을 처리하기 위해 `MySQL` 은 문서에 대한 특수한 인덱싱과 검색 매커니즘을 제공한다.

`MySQL` 은 `full-text index` 를 포함하며, 오라클은 `oracle text` 로 알려진 강력한 도구를 포함한다.

문서 검색은 특별한 경우에만 사용되는 만큼 여기서 예제를 보는건 의미가 없다.

### 인덱스 사용 방법

인덱스는 일반적으로 특정 테이블에서 행을 빨리 찾기 위해 사용한다.

```mysql
SELECT
	first_name,
	last_name
FROM customer
WHERE first_name LIKE 'S%' AND last_name LIKE 'P%';
```

```sh
first_name|last_name|
----------+---------+
SARA      |PERRY    |
SUE       |PETERS   |
SALLY     |PIERCE   |
```

이는 다음과 같은 전략중 하나를 결정할수 있다

- `Customer` 테이블의 모든 행을 스캔

- `last_name` 열의 인덱스를 사용해서 성이 `P` 로 시작하는 모든 고객을 찾는다. 그런다음 `customer`  테이블의 각 생을 읽어서 이름이 `S` 로 시작하는 행을 찾는다.

- `last_name` 과 `first_name` 열의 인덱스를 사용해서 성이 `P` 이고 이름이 `S` 로 시작하는 고객을 찾는다.

테이블을 다시 읽을 필요 없이 인덱스가 결괏셋에 필요한 모든 행을 생성하므로, 세번째가 가장 좋은 옵션이다.

다음은 `explain` 절을 사용하여 쿼리의 실행계획을 본다

```mysql
EXPLAIN
SELECT
first_name,
last_name
FROM customer
WHERE first_name LIKE 'S%' AND last_name LIKE 'P%';
```

```sh
select_type|table   |partitions|type |possible_keys|key          |
-----------+--------+----------+-----+-------------+-------------+
SIMPLE     |customer|          |range|idx_last_name|idx_last_name|
```

보면 `idx_last_name` 을 통해 쿼리한것을 볼 수있다
이는 아직 `last_name`, `first_name` 에 대한 인덱스를 생성하지 않아서이다.

```mysql
ALTER TABLE customer
ADD INDEX idx_full_name (last_name, first_name);
```

이는 `idx_full_name` 의 인덱스를 생성했다.
그리고 다시 쿼리해 본다

```mysql
EXPLAIN
SELECT
first_name,
last_name
FROM customer
WHERE first_name LIKE 'S%' AND last_name LIKE 'P%';
```

```sh
select_type|table   |partitions|type |possible_keys              |key          |
-----------+--------+----------+-----+---------------------------+-------------+
SIMPLE     |customer|          |range|idx_last_name,idx_full_name|idx_full_name|
```

보면 `idx_full_name` 을 사용한것을 볼 수 있다.
이는 더 효율적인 인덱스를 선택하여 쿼리한다는것을 볼 수 있다.

>[!note] `type` 열은 범위 스캔이 적용됨을 볼수있다.

### 인덱스의 단점

>[!info] 인덱스는 결국 특수한 유형의 테이블이기 때문에 행을 추가하거나 삭제할때마다 해당 테이블의 모든 인덱스를 수정해야 한다.

인덱스는 유용하지만 무엇이든 과용하는건 좋지 않다.
테이블의 행을 추가하거 삭제할때마다 해당 테이블의 모든 인덱스역시 수정작업이 이루어져야 한다.

이는 인덱스가 많을수록 서버가 모든 스키마를 최신 상태로 유지하기 위해 더 많은 작업을 해야 한다.
당연히 속도는 더 느려질것이다.

이는 디스크공간 뿐만아니라 관리자의 주의가 필요하므로, 가장 조흥 전략은 꼭 필요할때만 인덱스를 추가하는 것이다.

>[!note] 데이터웨어 하우스 경우 업무 시간 동안은 인덱스를 생성하지만, 업무 시간 이후 데이터가 웨어하우스에 로드될때 문자가 되는 인덱스를 삭제하고 업무 시간 전에 다시 만드는것이 일반적이라고 한다.

이를 위한 다음의 전략을 권장한다.

- **모든 기본 키 열에 인덱스가 만들어져 있는지 확인**<br>기본키 제약 조건을 만들때 대부분의 서버는 자동으로 고유 인덱스를 생성한다.<br><br>다중 열 기본키의 경우에는 기본 키 열의 서브셋 또는 모든 기본키 열에 대해 기본 키 제약 조건 정의와 다른 순서로 추가 인덱스를 생성할 것을 고려할 수 있다.


- **외래키 제약조건에서 참조되는 모든 열에 대해 인덱스를 작성**<br>서버는 부모 행이 삭제될때 자식행이 없는지 확인해야 한다. 열에 인덱스가 없다면 전체 테이블을 스캔한다.

- **데이터 검색에 자주 사용되는 열을 인덱싱한다.**<br>대부분의 날짜 열은 $2 \sim 50$ 자의 짧은 문자열 열과 함께 인덱스로 사용하기 좋은 후보이다. 
