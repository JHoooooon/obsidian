
---

문자열 데이터를 처리할때, 문자자료형중 하나를 사용한다

- **CHAR**<br>지정한 크기 보다 문자열이 작으면 나머지 공간을 공백으로 채운다.<br>고정 길이 문자열 자료형이다.<br>`MySQL` 은 `CHAR` 를 최대 `255` 자, 오라클 데이터베이스는 `2000` 자, `SQL` 서버는 `8000` 자 까지 허용한다.

- **varchar**<br>가변 길이 문자열 자료형이다.<br>`MySQL` 은 `varchar` 열에 최대 `65,535` 자를 허용한다.<br>오라클에서는 `varchar2` 로 `4000` 자, `SQL 서버`는 `8000` 자까지 허용한다.

- **text(`MySQL`  및 `SQL 서버`) 또는 `clob`(`오라클`)**<br>매우 큰 가변 길이 문자열을 저장한다. (`책에서는 문서라고 지칭`)<br>`MySQL` 에는 `최대 4기가 바이트` 크기의 문서를 저장하는 다양한 텍스트 자료형(`tinitext`, `text`, `mediumtext`, `longtext`) 가 있다.<br><br>`SQL 서버` 는 `최대 2기가 바이트` 크기의 문서를 저장하는 `text`  자료형이 있으며, `oracle` 은 `최대 128테라 바이트` 크기의 문서를 저장하는 `clob` 자료형이 포함된다.<br>`SQL 서버 2005` 또는 `varchar(max)` 자료형을 포함하는데, 향후 리리즈에서 제거될 `text` 자료형 대신 사용할것을 권장한다. 

## 문자열 생성

```mysql
CREATE TABLE string_tbl
(
char_fld CHAR(30),
vchar_fld VARCHAR(30),
text_fld TEXT
);
```

```mysql
INSERT INTO string_tbl (char_fld, vchar_fld, text_fld)
VALUES (
	'This is varchar data',
	'This is text data'
);
```

문자열 데이터를 테이블에 삽입할때, 문자열 길이가 해당 열의 최대 크기를 초과하면 서버에서 예외가 발생한다.

>[!info] 예외를 발생시키는 대신 문자열을 자동으로 잘라내도록 `MySQL` 및 `SQL Server` 를 설정할 수 있다.
`MySQL 6.0` 이후 기본 모드는 `strict` 모드이다.
문제가 생기면 예외를 발생시키는 모드로, 이전 버전의 서버에서는 문자열을 최대 크기로 자르고 경고만 했다

다음은 `Engine` 이 예외를 발생시키는 **대신 문자열을 자르고 경고를 발생하도록 하려면 `ANSI` 모드를 선택**해야 한다.

```mysql
SELECT @@session.sql_mode;
```

```sh
@@session.sql_mode                        
----------------------------------------------
STRICT_TRANS_TABLES, NO_ENGINE_SUBSTITUTION
```

다음은 `ansi` 모드로 변경한다

```mysql
SET sql_mode='ansi';
```

```sh
@@session.sql_mode                        
------------------------------------------------
REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,.....
```

이전에 경고가 발생한부분을 쿼리하려면 다음처럼 할수 있다.

```mysql
SHOW WARNINGS;
```

위의 `ansi` 모드로 인해, `vchar_fld` 열의 문자여 작업시 `30` 문자가 넘어가더라도, `30` 문자만큼 글자가 잘려서 저장되며, 경고가 발생할 뿐이다.

>[!info] 문자열 잘림을 방지하는 가장 좋은 방법은 저장할수 있는 가장 긴 문자열을 처리할수 있을 만큼 충분히 높게 열의 최댓값을 설정하는 것이다.
>
>서버는 문자열을 저장하기에 충분한 공간 할당만 사용하므로, `varchar` 열에 높은 최댓값을 설정한는게 낭비가 아니라는점이다.

### 작은 따옴표 포함

>[!info] 문자열은 `작은 따옴표` 로 구분되므로, `작은 따옴표` 나 `아포스트로피` 를 포함한 문자열을 다룰때 주의해야 한다.

```mysql
UPDATE string_tbl
SET text_fld = 'This string doesn't workd'
```

위는 당연히 안된다.
해당 언어의 `아포스트로피` 를 처리하기 위해 `escape` 해야 한다

>[!info] `아포스트로피` 에 `작은 따옴표`를 추가해서 `escape` 하거나, `Mysql` 혹은 `Oracle` 같은 경우 `\` 으로 `escape` 가능하다.

```mysql
UPDATE string_tbl
SET text_fld = 'This string didn''t work, but it does now'

UPDATE string_tbl
SET text_fld = 'This string didn\'t work, but it does now'
```

이를 위한 `quote` 내장 함수를 제공한다
이는 외부 파일을 읽어서 내용을 저장하는경우 유용하다

```mysql
SELECT quote(text_fld)
FROM string_tbl;
```

### 특수 문자 포함

`char()` 는 `ASCII` 캐릭터셋의 `255` 자 내에서 문자열을 생성할수 있다.

```mysql
SELECT 'abcdefg', CHAR(97, 98, 99, 100, 101, 102, 103);
```

```sh
abcdefg|CHAR(97, 98, 99, 100, 101, 102, 103)|
-------+------------------------------------+
abcdefg|abcdefg                             |
```

이러한 특성을 사용하면 특수문자 혹은 악센트 부호가 있는 문자를 사용할수 있다.

```mysql
SELECT CHAR(148); -- 'ö'
```

---

>[!warning] 제대로 작동하지 않는다. 뭐가 문제지? `148` 이 아닌가 싶어서, `ASCII` 로 코드를 확인해본다. 다음처럼 나온다.

이해가 안가는게 다음처럼 `ascii` 값을 찾아서 코드를 찾아본다.

```mysql
SELECT ASCII('ö'); 
```

```sh
ASCII('ö')|
----------+
       195|
```

```mysql
SELECT CHAR(195);
```

```sh
CHAR(195)|
---------+
Ã        |
```

전혀 다른 값이 나온다... 일단 이해가 가지 않아서, 넘어간다.

---

### 문자열 조작

각 데이터베이스 서버에는 문자열 조작을 위한 많은 내장 함수가 포함되어 있다.

```mysql
CREATE TABLE string_tbl (
	id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT,
	char_fld CHAR(30),
	varchar_fld VARCHAR(30),
	text_fld TEXT
);

INSERT INTO string_tbl (id, char_fld, vchar_fld, text_fld)
VALUES (
	null,
	'This string is 28 characters',
	'This string is 28 characters',
	'This string is 28 characters',
);
```

#### length(): 문자열의 갯수를 세는 내장함수

```mysql
SELECT
	LENGTH (char_fld) char_len,
	LENGTH (varchar_fld) vchar_len,
	LENGTH (text_fld) text
FROM string_tbl;
```

```sh
char_len|vchar_len|text|
--------+---------+----+
      28|       28|  28|
```

>[!info] `char` 는 `30` 인데, `char_len` 값은 `30` 이 아닌 `28` 이다.<br>이는 `고정문자열` 인 `char` 의 예상 결과 값과는 전혀다르다.<br><br>하지만, **`MySQL` 서버는 조회시, `char` 데이터에서 공백을 제거해주며, 문자열이 저장되는 열의 유형에 관계없이 모든 문자열 함수에서 동일한 결과를 반환한다.**

>[!note] 이부분은 뭔가 명확하지는 않다. 저장되는 데이터값은 `30` 인지 확인하는데, 여전히 `공백` 은 존재하지 않는듯하다.. <br><br> 적어도 `dbeaver` 는 `공백` 이 없어보였다... 자체적으로 처리하나? 일단 이렇다는것은 알아두자...

#### POSITION(sub_string IN field_name): 부문 문자열의 위치를 찾는 함수

`field` 에 있는 문자열에 포함되는 문자열의 시작점 위치를 숫자값으로 나타낸다

```mysql
SELECT
	POSITION ('characters' IN varchar_fld)
FROM string_tbl st;
```

```sh
POSITION ('characters' IN varchar_fld)|
--------------------------------------+
                                    19|
```

>[!note] 부문 문자열을 찾을수 없는 경우 `position()` 함수는 `0` 을 반환한다

>[!warning] `c like 언어` 및 `programming language` 같은경우, 요쇼의 `index` 의 값이 `0` 부터 시작한다.<br> `sql` 은 `1` 부터 시작하며, `0` 은 값이 없다는것으로 보면 된다.

#### LOCATE(sub_string, field_name, start_index): 특정 위치부터 부분 문자열과 일치하는 값의 위치를 찾는 함수

`locate` 함수는 `sub_string` , `field_name`, `start_index` 순으로 `start_index` 위치 이후에 `sub_string` 이 처음 나오는 위치를 숫자값으로 나타낸다

```mysql
SELECT
	LOCATE ('is', varchar_fld, 5)
FROM string_tbl;
```

```sh
LOCATE ('is', varchar_fld, 5)|
-----------------------------+
                           13|
```

>[!warning] `c like 언어` 및 `programming language` 같은경우, 요쇼의 `index` 의 값이 `0` 부터 시작한다.<br> `sql` 은 `1` 부터 시작하며, `0` 은 값이 없다는것으로 보면 된다.

#### STRCMP(): 첫번째 문자열과 두번째 문자열의 정렬위치를 비교

`STRCMP` 는 다음처럼 작동한다.

- **정렬 순서에서 첫번째 문자열이 두번째 문자열 앞에 오는 경우: -1**
- **정렬 순서에서 첫번째 문자열이 두번째 문자열이 동일한경우: 0**
- **정렬 순서에서 첫번째 문자열이 두번째 문자열 뒤에 오는 경우: 1**
- **문자열 비교시 대소문자 구별을 하지 않는다.**

```mysql
delete from string_tbl;

INSERT INTO string_tbl(id, varchar_fld)
VALUES
	( null, 'abcd'),
	( null, 'xyz'),
	( null, 'QRSTUV'),
	( null, 'qrstuv'),
	( null, '12345');
	
SELECT varchar_fld
FROM string_tbl st
ORDER BY varchar_fld;
```

```mysql
varchar_fld|
-----------+
12345      |
abcd       |
QRSTUV     |
qrstuv     |
xyz        |
```

```mysql
SELECT
	STRCMP('12345', '12345') `12345_12345`,
	STRCMP('abcd', 'xyz') `abce_xyz`,
	STRCMP('abcd', 'QRSTUV') `abcd_QRSTUV`,
	STRCMP('qrstuv', 'QRSTUV') `qrstuv_QRSTUV`,
	STRCMP('12345', 'xyz') `12345_xyz`,
	STRCMP('xyz', 'qrstuv') `xyz_qrstuv`;
```

```sh
12345_12345|abce_xyz|abcd_QRSTUV|qrstuv_QRSTUV|12345_xyz|xyz_qrstuv|
-----------+--------+-----------+-------------+---------+----------+
          0|      -1|         -1|            0|       -1|         1|
```

1. `12345_12345`: 동일한 위치 값을 가지니 `0`
2. `abce_xyz`: `abcd` 가 `xyz` 보다 앞에 있으니 `-1`
3. `abcd_QRSTUV`: `abce` 가 `QRSTUV` 보다 앞에 있으니 `-1`
4. `qrstuv_QRSTUV`: `qrstuv` 가 `QRSTUV` 와 비교시 대소문자 비교를 하지 않으므로 `0`
5. `12345_xyz`: `12345` 가 `xyz` 보다 앞에 있으니 `-1`
6. `xyz_qrstuv`: `xyz` 가 `qrstuv` 보다 뒤에 있으니 `1`

##### `strcmp` 없이 `like` 와 `regexp` 를 사용하여 문자열 비교 

`select` 절의 문자열 비교시 `1` 또는 `0` 값을 산출한다.
이러한 부분을 활용하면 비교연산이 가능하다

```mysql
SELECT
	name,
	name LIKE '%y' end_in_y
FROM category;
```

```sh
name       |end_in_y|
-----------+--------+
Action     |       0|
Animation  |       0|
Children   |       0|
Classics   |       0|
Comedy     |       1|
Documentary|       1|
Drama      |       0|
Family     |       1|
Foreign    |       0|
Games      |       0|
Horror     |       0|
Music      |       0|
New        |       0|
Sci-Fi     |       0|
Sports     |       0|
Travel     |       0|
```

`regexp` 역시 똑같이 비교연산이 가능하다

```mysql
SELECT
	name,
	name REGEXP 'y$' end_in_y
FROM category c;
```

```sh
name       |end_in_y|
-----------+--------+
Action     |       0|
Animation  |       0|
Children   |       0|
Classics   |       0|
Comedy     |       1|
Documentary|       1|
Drama      |       0|
Family     |       1|
Foreign    |       0|
Games      |       0|
Horror     |       0|
Music      |       0|
New        |       0|
Sci-Fi     |       0|
Sports     |       0|
Travel     |       0|
```

지정된 정규식 및 문자열의 조건이 일치하면 `1` 을 반환하는것을 볼수 있다

#### CONCAT(string, ...string): 문자열 연결함수 

문자열을 연결하는 함수인 `concat` 이다.
굉장히 많이 쓰이는 함수이다.

```mysql

```
