`집계 함수` 는 그룹의 모든 행에 대해 특정 연산을 수행한다.

모든 데이터베이스 서버는 고유한 `distinct` 특별 집계 함수를 포함하지만, 대부분의 서버에서 가지고 있는 공통 집계 함수는 다음과 같다.

- **MAX**(): 집합내의 최댓값 반환
- **MIN**(): 집합의 최솟값 반환
- **AVG**(): 집합의 평균값 반환
- **SUM**(): 집합의 총합 반환
- **COUNT**(): 집합의 레코드 수를 반환

#### 영화 대여료 데이터 분석 쿼리

공통 집계 함수를 사용해서 영화 대여료의 데이터를 분석하는 쿼리다

```mysql
SELECT 
	MAX(amount) max_amt,
	AVG(amount) avg_amt,
	MIN(amount) min_amt,
	SUM(amount) tot_amt,
	COUNT(*) num_payment,
FROM payment;
```

```sh
max_amt|avg_amt |min_amt|tot_amt |num_payment|
-------+--------+-------+--------+-----------+
  11.99|4.201356|   0.00|67406.56|      16044|
```

`amount` 를 사용하여, 집계함수로 계산된 결과를 반환한다.

### 명시적 그룹과 암시적 그룹

`GROUP BY` 절이 없는데, `집계함수` 를 사용하면 `암시적 그룹` 이라 한다.
반면, `GROUP BY` 절을 명시적으로 선언하면, `명시적 그룹` 이라 할수 있다.

앞전의 [[#영화 대여료 데이터 분석 쿼리]] 는 `GROUP BY` 절 없이 사용했으니 단일 `암시적 그룹` 이라 할수 있다.

앞의 [[#영화 대여료 데이터 분석 쿼리]] 에서는 `암시적` 으로 `payment` 의 모든 행이다.

> [!info] 이러한 경우 `테이블의 모든 행` 이 `GROUP BY` 대상이 된다<br>그러므로, 집계함수에 외의 `field` 를 `SELECT` 하려고 하면, `ERROR` 가 발생한다.

만약, 다음처럼 `amount` 가 아닌 다른 `field` 를 사용하면, 데이터베이스는 그룹지어져야할 `field` 를 알수없어 `ERROR` 가 발생한다.

```mysql
SELECT 
	customer_id,
	MAX(amount) max_amt,
	AVG(amount) avg_amt,
	MIN(amount) min_amt,
	SUM(amount) tot_amt,
	COUNT(*) num_payment
FROM payment;
```

```sh
SQL Error [1140] [42000]: In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'sakila.payment.customer_id'; this is incompatible with sql_mode=only_full_group_by
```

>[!warning] 
>`GROUP BY 절 없이 집계된 쿼리를 사용했다` 는 것과 더불어 추가적으로  `SELECT` 목록에 비집계된 `sakila.payment.customer_id` 의 `column` 이 포함되었으며,<br> 
>이는 `sql_mode=only_full_group_by` 에 의해 호환되지 않는다는 에러가 발생한다 

>[!info] [ONLY_FULL_GROUP_BY](https://dev.mysql.com/doc/refman/8.4/en/sql-mode.html#sqlmode_only_full_group_by)
 `SELECT` 리스트, `ORDER BY` 목록 혹은 `HAVING condition` 에서 `GROUP BY` 절에 명시되지 않은 `column` 을 사용할때 쿼리를 거부한다.<br><br> 이는 `GROUP BY` 절에 명명되지도 않거나, `GROUP BY` 절`column` 에 기능적으로 종속되지 않은 열을 참조하는 쿼리를 거부한다고 보면 된다. 

이러한 에러는 `GROUP BY` 에 의해 `명시적` 으로 지정해야 한다는 의미이다

```mysql
SELECT 
	customer_id,
	MAX(amount) max_amt,
	AVG(amount) avg_amt,
	MIN(amount) min_amt,
	SUM(amount) tot_amt,
	COUNT(*) num_payment,
FROM payment
GROUP BY customer_id
LIMIT 5;
```

```sh
customer_id|max_amt|avg_amt |min_amt|tot_amt|num_payment|
-----------+-------+--------+-------+-------+-----------+
          1|   9.99|3.708750|   0.99| 118.68|         32|
          2|  10.99|4.767778|   0.99| 128.73|         27|
          3|  10.99|5.220769|   0.99| 135.74|         26|
          4|   8.99|3.717273|   0.99|  81.78|         22|
          5|   9.99|3.805789|   0.99| 144.62|         38|
```

이는 `customer_id` 를 그룹화 하고, 각 `customer_id` 의  `amount` 를 집계함수로 계산한다.

### 고유한 값 계산

각 그룹에서 `COUNT()` 함수를 사용할 때, 그룹의 모든 `customer_id` 수를 계산할지 (중복포함),
아니면 그룹의 모든 `customer_id` 중에 `고유한 값`(`distinct value`) 에 대해서만 계산할지 선택할 수 있다

```mysql
SELECT 
	COUNT(customer_id) num_rows,
	COUNT(DISTINCT customer_id) num_customers	
FROM payment;
```

```sh
num_rows|num_customers|
--------+-------------+
   16044|          599|
```

쿼리의 첫 번째 열은 단순히 `payment` 테이블의 행 수를 계산하는 반면 두번째 열은 `customer_id` 의 값을 비교해서 고유한 값을 가지는 `customer_id` 의 수만 계산한다.

### 표현식 사용

함수를 집계할때는 인수로 열 이외에 표현식도 사용할 수 있다.
이는 영화를 대여한 후 반환하기 까지 걸린 최대 일 수를 쿼리한다

```mysql
SELECT MAX(DATEDIFF(return_date, rental_date))
FROM rental;
```

```sh
MAX(datediff(return_date, rental_date))|
---------------------------------------+
                                     10|
```

`DATEDIFF` 는 시작일, 종료일까지의 일수를 반환하며, `MAX` 집계함수는 그중 최대 값을 가져온다
이는 `CASE` 표현식을 사용해서 특정 행을 집계에 포함해야 할지 여부를 결정할수도 있다

`CASE` 는 추후 챕터에서 설명한다.

### NULL 처리 방법

>[!info] 집계를 하거나 실제로 모든 유형의 숫자를 계산할 때는 항상 `NULL` 값이 계산 결과에 어떤 영향을 미칠지 고려해야 한다.

```mysql
CREATE TABLE number_tbl (val SMALLINT);

INSERT INTO number_tbl VALUES (1);
INSERT INTO number_tbl VALUES (3);
INSERT INTO number_tbl VALUES (5);

SELECT 
	COUNT(*) num_rows,
	COUNT(val) num_vals,
	SUM(val) total,
	MAX(val) max_val,
	AVG(val) avg_val
FROM number_tbl;
```

```sh
num_rows|num_vals|total|max_val|avg_val|
--------+--------+-----+-------+-------+
       3|       3|    9|      5| 3.0000|
```

이 같은 경우 제대로 동작한다.
 [[#명시적 그룹과 암시적 그룹]]  에서 설명한 **단일 암시적 그룹** 이므로, 집계함수를 사용하여 처리하는것을 볼수 있다.

다음의 `NULL` 값을 갖는 쿼리를 넣어본다

```mysql
INSERT INTO number_tbl VALUES (NULL);

SELECT 
	COUNT(*) num_rows,
	COUNT(val) num_vals,
	SUM(val) total,
	MAX(val) max_val,
	AVG(val) avg_val
FROM number_tbl;
```

```sh
num_rows|num_vals|total|max_val|avg_val|
--------+--------+-----+-------+-------+
       4|       3|    9|      5| 3.0000|
```

`num_rows` 는 `4` 인데, `num_vals` 는 `3` 이다.
여기서 중요한 부분은 `val` 열에 저장된 값의 수를 계산하는 만큼 `NULL` 값을 무시하고 센다는 것이다
