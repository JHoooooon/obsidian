
---

>[!info] 원치않는 데이터를 걸러내는 방법에는 여러가지가 있다<br><br>
>포함하거나 제외할 특정 값, 값의 집합 또는 값의 범위를 찾아내거나, 다양한 패턴 검색 기술을 사용하여 문자열 데이터를 처리할 때 부분 일치를 찾을수있다.

### 동등 조건

값 비교시 같을때, `True`

```mysql
title = 'RIVER OUTLAW'
fed_id = '111-11-1111'
```

### 부등조건

값 비교시 다를때, `True`

```mysql
select c.email
from customer c
	inner join rental r
	on c.customer_id = r.customer_id
where date(r.rental_date) <> '2005-06-14';
```

>[!info] `<>` 혹은 `!=` 으로 사용가능하다


### 범위 조건

해당 식이 범위내에 있는지 확인하는 조건
숫자 또는 시간 데이터로 작업시 많이 사용

```mysql
select cosutomer_id, rental_date
from rental
where rental_date > '2005-05-25';
```

`2005-05-25` 보다큰 데이터 쿼리

```mysql
select cosutomer_id, rental_date
from rental
where rental_date <= '2005-06-16' and
	rental_date >= '2005-06-14;
```

`2005-06-16` 보다 작거나 같고, `2005-06-14`  보다 크거나 같은 데이터 쿼리 

이는 다음처럼 작성도 가능하다

```mysql
select cosutomer_id, rental_date
from rental
where rental_date between '2005-06-14' and '2005-06-16'; 
```

>[!warning] `between` 연산자 작성시 `하한값` 먼저 작성하고, `상한값`  을 작성해야 한다.

이는 서버가 내부적으로 다음처럼 두가지 조건을 생성한다고 한다.

```mysql
select cosutomer_id, rental_date
from rental
where 
	rental_date >= '2005-06-14' and
	rental_date <= '2005-06-16'; 
```

만약, `상한값` 을 먼저 작성하면 다음의 쿼리가 된다.

```mysql
select cosutomer_id, rental_date
from rental
where 
	rental_date >= '2005-06-16' and
	rental_date <= '2005-06-14'; 
```

이는 `2005-06-16` 보다 크거나 같고, `2005-06-14` 보다 작거나 같아야 하므로, 일치하는 값이 없다.

>[!warning] 또 다른 유의 사항은 상한값과 하한값이 범위에 `포함` 되어 결과셋에 포함된다.<br><br> 시간 구성 요소를 비교할때, 시간을 지정하지 않으면, 기본적으로 자정으로 설정된다.<br><br>`2006-06-14 00:00:00` 부터 `2005-06-16 00:00:00` 까지로, `6/14` 부터 `6/15` 일자의 모든 대여 내역이 포함된다. 

만약, `2005-06-16` 으로 지정한것이 `6/16`  을 포함해야 한다면, `2005-06-17` 로 해야 `6/14 - 6/16` 전체를 대여내역에 포함할 것이다.

다음은 숫자 범위를 지정하는 조건이다.

```mysql
select customer_id, payment_date, amount
from payment
where amount between 10.0 and 11.99;
```

이는 `10.0` 부터 `11.99` 까지의 `amount` 를 가진 데이터를 출력한다.

### 문자열 범위

문자열 범위는 약간 애매한 경우이다.
`FA` 와 `FR` 사이의 성이 속하는 고객을 반환하는 쿼리이다.

```mysql
select last_name, first_name
from customer
where last_name between 'FA' and 'FR';
```

```sh
last_name |first_name|
----------+----------+
FARNSWORTH|JOHN      |
FENNELL   |ALEXANDER |
FERGUSON  |BERTHA    |
FERNANDEZ |MELINDA   |
FIELDS    |VICKI     |
FISHER    |CINDY     |
FLEMING   |MYRTLE    |
FLETCHER  |MAE       |
FLORES    |JULIA     |
FORD      |CRYSTAL   |
FORMAN    |MICHEAL   |
FORSYTHE  |ENRIQUE   |
FORTIER   |RAUL      |
FORTNER   |HOWARD    |
FOSTER    |PHYLLIS   |
FOUST     |JACK      |
FOWLER    |JO        |
FOX       |HOLLY     |
```

이 같은 경우 `FR` 이 포함되지 않는다.
책에서는 `FRANKLIN` 과 같은 이름은 범위를 벗어나므로 결과에 포함되지 않는다고 한다.

>[!note] `FR` 까지 검색하는것이 아니라, 모든 문자열을 비교 분석하는건가?
>
>`FR` 비교시 두 글자만 비교하지 않는듯하다..?
>
>내 생각이 맞다면, `FR` 이전의 글자들은 `2` 글자만 비교시 크기값이 작으므로,  포함된다.
>
>`FR` 이후의 글자는 `FR` 이라는 공통된 문자를 발견하는 즉시 그다음 문자열을 포함해서 `FR` 값과 비교하는듯하다.
>
> 그러므로 `FRA` 부터는 `FR` 보다 큰값이 되므로  포함안된다.
> 
> **이는 순전히 내 생각일 뿐이다.**

이처럼 문자열 범위를 사용하려면 사용하려는 캐릭터셋의 문자 순서를 알아야 한다.

>[!info] 이러한 캐릭터셋 문자가 정렬되는 순서 규칙을 `콜레이션`(`collation`) 이라 한다.

### 맴버십조건

>[!note] 경우에 따라서는 표현식을 단일 값 또는 값의 범위로 제한하는 대신 **유한한 값의 집합으로 제한**해야 한다.

```mysql
select title, rating
from film
where rating = 'G' or rating = 'PG';
```

이는 `or` 연산자이므로 `G` 또는 `PG` 값을 가진 데이터를 쿼리한다.

이는 필터조건시 필터해야할 양이 많아지면 `where` 절이 많이 늘어날 우려가 있다.

이에 대한 대첵으로 `in` 연산자가 있다

```mysql
select title, rating
from film
where rating in('G', 'PG');
```

이는 이전의 `query` 와 같다.

### 서브쿼리 사용

`in` 연산자는 고유한 표현식 집합을 작성하듯 서브쿼리로 즉시 집합을 생성할 수 있다.

```mysql
select title, rating
from film
where rating in (
	select rating 
	from film 
	where title like '%PET%'
);
```

위의 서브쿼리는 `PET` 이 중간에 들어간 모든 영화의 타이틀에 일치하면, 해당하는 영화의 `rating`  값을 출력한다.

```mysql
select distinct rating from film where title like '%PET%';
```

```sh
rating|
------+
G     |
PG    |
```

`rating`  은 `G` 와 `PG` 를 출력하는것을 볼 수있다.
그러므로 다음처럼 계산된다

```mysql
select title, rating
from film
where rating in ('G', 'PG'); -- %PET% 을 쿼리한 출력값
```

이는 모든 `film` 의 목록중 `ratin` 이 `G`, `PG`  과 같으면 값을 포함해서 출력한다.

### NOT IN 사용

>[!info] 표현식 집합 내 존재하지 않는지 여부를 확인한다

```mysql
select title, rating
from film
where rating not in ('PG-13', 'R', 'NC-17')
```

### 일치조건

>[!info] 부분 문자열 처리를  `일치조건`(`matching conditions`) 라한다.

```mysql
select last_name, first_name
from customer c
where left(last_name, 1) = 'Q';
```

```sh
last_name  |first_name|
-----------+----------+
QUALLS     |STEPHEN   |
QUINTANILLA|ROGER     |
QUIGLEY    |TROY      |
```

이를 보면 `last_name`  의 첫번째 문자가 `Q` 인경우 `True`  이다.

이는 내장함수를 사용하여 처리한것이며, 문자 검색 표현식으로 더 간단하게 처리 가능하다.

`wildcard` 목록

| 와일드 카드 문자 | 일치                       |
| :-------- | ------------------------ |
| -         | 정확히 한 문자                 |
| %         | 개수에 상관없이 모든 문자(0 포함)<br> |

```mysql
select last_name, first_name
from customer
where last_name LIKE '_A_T%S';
```

```sh
last_name|first_name|
---------+----------+
MATTHEWS |ERICA     |
WALTERS  |CASSANDRA |
WATTS    |SHELLY    |
```

### 정규표현식 사용

와일드카드 문자로 유연성이 충분히지 않을 수 있다.
이때 사용하는것이 `REGEXP` 이다.

다음은 정규표현식을 상요하여 쿼리한것이다

```mysql
select last_name, first_name
from customer
where last_name regexp '^[QY]';
```

```sh
last_name  |first_name|
-----------+----------+
YOUNG      |CYNTHIA   |
QUALLS     |STEPHEN   |
QUINTANILLA|ROGER     |
YANEZ      |LUIS      |
YEE        |MARVIN    |
QUIGLEY    |TROY      |
```

