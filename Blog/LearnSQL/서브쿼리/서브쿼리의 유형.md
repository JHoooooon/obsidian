
서브쿼리에서 반환된 결과 셋의 유형은 다음과 같다

- **단일 열을 가진 단일 행**
- **단일 열을 가진 다중 행**
- **다중 열을 가진 다중 행**

언급한 차이점과 더불어 서브쿼리를 구별할 수 있는 다른 기능들을 쓸수 있다.

- **비상관 서브쿼리**(`noncorrelated subqueries`):  완전히 독립적으로 실행하는 서브쿼리
- **상관 서브쿼리**(`correlated subquery`):  포함 구문의 열을 참조하는 서브쿼리

이러한 유형의 서브쿼리를 알아본다

## 비상관 서브쿼리

단독으로 실행될수 있으며 포함 구문에서 아무것도 참조 하지 않는다
`UPDATE` 혹은 `DELETE` 를 사용하지 않는한, 이러한 유형의 서브쿼리를 가장 많이 사용한다. 

### 단일 열을 가진 단일 행을 반환하는 서브쿼리

**단일 행과 단일 열**이 포함된 결과셋을 반환하는 쿼리를 **스칼라 서브쿼리(`scalar subquery`)** 라고 한다.
이러한 유형의 서브쿼리는 일반적인 연산자($=$, $>$, $<$, $<=$, $>=$, $<>$, $!=$) 을 사용하여 조건의 양쪽에 기술할 수 있다

```mysql
SELECT
	city_id,
	city
FROM city
WHERE country_id <> (
	SELECT
		country_id
	FROM country
	WHERE country = 'India'
);
```

```sh
city_id|city                      |
-------+--------------------------+
    251|Kabul                     |
     59|Batna                     |
     63|Béchar                    |
    483|Skikda                    |
    516|Tafuna                    |
     67|Benguela                  |
    360|Namibe                    |
	...
```

위는 `India` 의 `country_id` 를 서브쿼리하고, `India` `country_id` 가 아닌 모든 `city` 를 쿼리한다.
동등조건에서 서브쿼리를 사용했을때 서브쿼리가 둘 이상의 행을 반환하면 오류가 발생한다.

```mysql
SELECT
	city_id,
	city
FROM city
WHERE country_id <> (
	SELECT
		country_id,
		country
	FROM country
	WHERE country = 'India'
);
```

```sh
SQL Error [1241] [21000]: Operand should contain 1 column(s)
```

>[!warning] `피연산자` 는 하나의 `column` 만 포함해야 한다고 경고한다.


### 단일 열을 가진 다중 행을 반환하는 서브쿼리

서브쿼리가 두개 이상의 행을 반환할 경우, 동등조건을 사용할수 없다
대신 이런 유형의 서브쿼리와 함께 조건을 작성할 수 있는 $4$개의 추가 연산자가 있다

#### IN 연산자, NOT IN 연산자

단일 열을 가진 다중 행을 반환하는 서브쿼리는 하나의 집합의 개념으로 볼수 있다
다음은 단일 열을 가진 다중 행을 반환하는 쿼리이다

```mysql
SELECT country_id
FROM country
WHERE country = 'Canada' OR country = 'Mexico';
```

```sh
country_id|
----------+
        20|
        60|
```

이 쿼리는 `country_id` 가 $20$, $60$ 의 값을 가진 집합으로 볼 수 있다
이제 이 쿼리를 서브쿼리로 사용하여 조건을 작성한다.

```mysql
SELECT 
	city_id,
	city
FROM city
WHERE country_id IN (
	SELECT country_id
	FROM country
	WHERE country = 'Canada' OR country = 'Mexico'
);
```

```sh
city_id|city                      |
-------+--------------------------+
    179|Gatineau                  |
    196|Halifax                   |
    300|Lethbridge                |
    313|London                    |
    383|Oshawa                    |
	...
```

만약, `Canada` 와 `Mexico` 의 도시가 아닌 모든 도시의 데이터셋을 쿼리한다면 `NOT IN` 을 사용하면 된다.

#### ALL 연산자

`IN` 연산자는 하나의 표현식이 표현식 집합 내에 있는지 여부를 확인한다
반면 `ALL` 연산자는 한 집합의 모든 값과 하나의 값을 비교할수 있다.

```mysql
SELECT 
	frist_name,
	last_name
FROM customer
WHERE customer_id <> ALL(
	SELECT customer_id
	FROM payment
	WHERE amount = 0
);
```

```sh
first_name|last_name |
----------+----------+
MARY      |SMITH     |
PATRICIA  |JOHNSON   |
LINDA     |WILLIAMS  |
BARBARA   |JONES     |
ELIZABETH |BROWN     |
JENNIFER  |DAVIS     |
MARIA     |MILLER    |
SUSAN     |WILSON    |
...
```

이는 `customer_id` 의 값이 `ALL` 연산자의 집합에 포함되지 않는 모든 데이터셋을 반환한다.

>[!warning] 대부분의 사람들은 `ALL` 연산자 사용을 선호하지 않는다고 말한다.

`ALL` 대신 `NOT IN` 을 사용하여 동일한 쿼리를 만들 수 있다

```mysql
SELECT
	first_name,
	last_name
FROM customer
WHERE customer_id NOT IN (
	SELECT customer_id
	FROM payment
	WHERE amount = 0
);
```

>[!info] 이는 선호도의 문제라고 한다.

>[!warning] `NOT IN` 혹은 `ALL` 을 사용해서 하나의 집합 내의 값들과 비교할 경우, 집합에 `NULL` 값을 포함하지 않도록 해야 한다.<br><br>표현식의 왼쪽에 있는 값의 집합의 각 맴버와 비교하는데 `NULL` 값과 비교하면 `UNKNOWN` 이 발생한다.

```mysql
SELECT
	first_name,
	last_name
FROM customer
WHERE customer_id NOT IN (122, 452, NULL);
```

```sh
first_name|last_name|
----------+---------+
```

>[!warning] 이렇게 `UNKNOW` 이 발생하면 빈 집합을 반환한다..

`ALL` 연산자를 사용하는 다른예제로 `HAVING` 절에 있는 경우이다

```mysql
SELECT
	customer_id,
	COUNT(*)
FROM rental
GROUP BY customer_id
HAVING COUNT(*) > ALL(
	SELECT COUNT(*)
	FROM rental r
		INNER JOIN customer c
		ON r.customer_id = c.customer_id
		INNER JOIN address a
		ON a.address_id = c.address_id
		INNER JOIN city ct
		ON ct.city_id = a.city_id
		INNER JOIN country co
		ON ct.country_id = co.country_id
	WHERE co.country IN ('United States', 'Mexico', 'Canada')
	GROUP BY r.customer_id
);
```

```sh
customer_id|COUNT(*)|
-----------+--------+
        148|      46|
```

모든 북미 고객의 총 대여횟수보다 많은 대여횟수를 가진 고객을 쿼리한다.

#### ANY 연산자

`ALL` 연산자와 마찬가지로 `ANY` 연산자도 값 집합의 맴버와 하나의 값을 비교할수 있다.
그러나 **다수의 비교값중 하나라도 만족하면 `TRUE` 를 반환한다.**

```mysql
SELECT
	customer_id,
	SUM(p.amount)
FROM payment p
GROUP BY customer_id
HAVING SUM(p.amount) > ANY (
	SELECT SUM(p2.amount)
	FROM payment p2
	INNER JOIN customer c
	ON p2.customer_id = c.customer_id
	INNER JOIN address a
	ON c.address_id = a.address_id
	INNER JOIN city ct
	ON a.city_id = ct.city_id
	INNER JOIN country co
	ON ct.country_id = co.country_id
	WHERE co.country IN ('Bolivia', 'Paraguay', 'Chile')
	GROUP BY co.country
);
```

```sh
customer_id|SUM(p.amount)|
-----------+-------------+
        137|       194.61|
        144|       195.58|
        148|       216.54|
        178|       194.61|
        459|       186.62|
        526|       221.55|
```

### 다중 열 서브쿼리

여태까지 살펴본 서브쿼리 예제는 단일 열과 하나 이상의 다중 행을 반환하는 서브쿼리였다
그러나 상황에 따라서 둘 이상의 열을 반환하는 다중 열 서브쿼리를 사용해야 할 수도 있다.

```mysql
SELECT
	fa.actor_id ,
	fa.film_id 
FROM film_actor fa
WHERE fa.actor_id IN (
	SELECT
		actor_id
	FROM actor
	WHERE last_name = 'MONROE'
);
```

```sh
actor_id|film_id|
--------+-------+
     120|     57|
     120|     63|
     120|    144|
     120|    149|
	 ...
```

이는 `MONROE` 이름을 가진 배우의 모든 `actor_id` 와 `film_id` 를 가져온다.
이제 `MONROE` 이름을 가진 배우가 `PG` 영화에 출연한 모든 데이터셋을 출력하려면 다음처럼 할수 있다.

```mysql
SELECT
	fa.actor_id,
	fa.film_id
FROM film_actor fa
WHERE (fa.actor_id, film_id) IN (
	SELECT
		a.actor_id,
		f.film_id
	FROM actor a
		CROSS JOIN film f
	WHERE a.last_name = 'MONROE'
	AND f.rating = 'PG'
);
```

```sh
actor_id|film_id|
--------+-------+
     120|     63|
     120|    144|
     120|    414|
     120|    590|
     120|    715|
     120|    894|
     178|    164|
     178|    194|
     178|    273|
     178|    311|
     178|    983|
```

이는 두 열을 괄호로 묶어 서브쿼리에 반환된 열과 비교하여 출력한다.

>[!info] 지금 같은경우 `CROSS JOIN` 을 사용하여 서브쿼리를 리턴한다.<br><br> `CROSS JOIN` 은 주체가 되는 `actor` 의 각 `row` 와 `JOIN` 될 `film` 의 모든 `row` 를 나열한 방식이다.<br><br> `데카르트곱` 에 의한 모든 경우의 수를 나열한 테이블이라고 생각하는게 편할듯 싶다.<br><br> 이를 통해 `WHERE` 절에서 `last_name` 및 `rating` 의 조건에 맞는 `Column` 을 반환하는 서브쿼리이다.

## 상관 서브쿼리

>[!info] 상관서브쿼리는 하나 이상의열을 참조하는 포함 구문으로 의존적인 쿼리이다.

>[!warning] **비상관서브쿼리는 각 후보 행에 대해 한번씩 실행**되지만, **상관서브쿼리는 포함 구문을 실행하기전에 실행되지 않는다**

> [!info] `포함 구문` 이라고 표현하는데, 이 서브쿼리를 포함하는 부모 쿼리를 말한다.<br>내가 내용이 헷갈려서 적어놓는다.

```mysql
SELECT
	c.first_name,
	c.last_name
FROM customer c
WHERE 20 = (
SELECT COUNT(*)
	FROM rental r
	WHERE r.customer_id = c.customer_id -- 상관쿼리
										-- 현재 c 의 customer_id 를 참조
);
```

`참조되는 column` 에 의해, 서브쿼리가 의존적이라 `포함 구문`(`부모쿼리를 말함`) 이 먼저 쿼리된다.
`부모의 참조되는 column` 이 행마다 `상관서브쿼리` 쿼리를 다시 실행한다.

이 쿼리는 `customer` 테이블에서 `599` 개의 행을 모두 검색하고, 각 고객에 대해 한번씩 서브쿼리를 실행해서 고객 ID 를 전달한다.

서브쿼리가 값 `20` 을 반환하면 필터 조건이 충족되고 해당 행의 결과셋에 추가된다

```mysql
first_name|last_name  |
----------+-----------+
LAUREN    |HUDSON     |
JEANETTE  |GREENE     |
TARA      |RYAN       |
WILMA     |RICHARDS   |
JO        |FOWLER     |
KAY       |CALDWELL   |
DANIEL    |CABRAL     |
ANTHONY   |SCHWAB     |
TERRY     |GRISSOM    |
LUIS      |YANEZ      |
HERBERT   |KRUGER     |
OSCAR     |AQUINO     |
RAUL      |FORTIER    |
NELSON    |CHRISTENSON|
ALFREDO   |MCADAMS    |
```

>[!warning] 한가지 주의할 점은, 상관 쿼리는 포함 쿼리의 각 행에 대해 한번씩 실행되므로, 포함 쿼리가 많은 행을 반환할 경우 상관쿼리를 사용하면 성능 문제가 발생할수 있다고 말한다.

다음은 `WHERE` 절에서 범위조건을 사용하여 상관서브쿼리를 사용한 예시이다.

```mysql
SELECT
	c.first_name,
	c.last_name
FROM customer c
WHERE (
	SELECT 
		SUM(p.amount)
	FROM payment p
	WHERE p.customer_id = c.customer_id
)
BETWEEN 180 AND 240;
```

```sh
first_name|last_name|
----------+---------+
RHONDA    |KENNEDY  |
CLARA     |SHAW     |
ELEANOR   |HUNT     |
MARION    |SNYDER   |
TOMMY     |COLLAZO  |
KARL      |SEAL     |
```

###  EXISTS 연산자

동등 및 범위조건에서 상관 서브쿼리를 사용하는 경우는 자주 볼수 있지만, 상관 서브쿼리로 조건을 작성할때 가장 일반적으로 사용되는 연산자는 `EXISTS` 연산자이다.

**이는 수량에 관계없이 관계가 존재하는지 확인하고자 EXISTS 연산자를 사용한다**

```mysql
SELECT
	c.first_name ,
	c.last_name
FROM customer c
WHERE EXISTS (
	SELECT 1
	FROM rental r
	WHERE r.customer_id = c.customer_id
	AND DATE(r.rental_date) < '2005-05-25'
)
```

>[!info] `EXISTS` 는 반환되는 열이 $0$ 개 이면 $0$ 을, $1$ 개 이상이면 $1$ 을 반환한다.

위의 서브쿼리에서는 반환되는 필터링된 열이 항상 존재하고, 부모쿼리는 해당하는 열을 반환하는 내용과 같다.  

이는 서브쿼리에서 조건을 필터링하고 나오는 값이 $1$ 이기 때문이다.

다음은 `R` 등급 영화에 출연한 적이 한번도 없는 모든 배우를 찾는다

```mysql
SELECT
	a.first_name,
	a.last_name
FROM actor a
WHERE NOT EXISTS
(
	SELECT 1
	FROM film_actor fa
		INNER JOIN film f
		ON fa.film_id = f.film_id
	WHERE fa.actor_id = a.actor_id
	AND f.rating = 'R'
)
```

```sh
first_name|last_name|
----------+---------+
JANE      |JACKMAN  |
```

`NOT` 연산자를 앞에 붙혀 사용하면 된다.

### 상관 서브쿼리를 ㅣ