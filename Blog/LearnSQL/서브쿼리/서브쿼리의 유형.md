
서브쿼리에서 반환된 결과 셋의 유형은 다음과 같다

- **단일 열을 가진 단일 행**
- **단일 열을 가진 다중 행**
- **다중 열을 가진 다중 행**

언급한 차이점과 더불어 서브쿼리를 구별할 수 있는 다른 기능들을 쓸수 있다.

- **비상관 서브쿼리**(`noncorrelated subqueries`):  완전히 독립적으로 실행하는 서브쿼리
- **상관 서브쿼리**(`correlated subquery`):  포함 구문의 열을 참조하는 서브쿼리

이러한 유형의 서브쿼리를 알아본다

## 비상관 서브쿼리

단독으로 실행될수 있으며 포함 구문에서 아무것도 참조 하지 않는다
`UPDATE` 혹은 `DELETE` 를 사용하지 않는한, 이러한 유형의 서브쿼리를 가장 많이 사용한다. 

### 단일 열을 가진 단일 행을 반환하는 서브쿼리

**단일 행과 단일 열**이 포함된 결과셋을 반환하는 쿼리를 **스칼라 서브쿼리(`scalar subquery`)** 라고 한다.
이러한 유형의 서브쿼리는 일반적인 연산자($=$, $>$, $<$, $<=$, $>=$, $<>$, $!=$) 을 사용하여 조건의 양쪽에 기술할 수 있다

```mysql
SELECT
	city_id,
	city
FROM city
WHERE country_id <> (
	SELECT
		country_id
	FROM country
	WHERE country = 'India'
);
```

```sh
city_id|city                      |
-------+--------------------------+
    251|Kabul                     |
     59|Batna                     |
     63|Béchar                    |
    483|Skikda                    |
    516|Tafuna                    |
     67|Benguela                  |
    360|Namibe                    |
	...
```

위는 `India` 의 `country_id` 를 서브쿼리하고, `India` `country_id` 가 아닌 모든 `city` 를 쿼리한다.
동등조건에서 서브쿼리를 사용했을때 서브쿼리가 둘 이상의 행을 반환하면 오류가 발생한다.

```mysql
SELECT
	city_id,
	city
FROM city
WHERE country_id <> (
	SELECT
		country_id,
		country
	FROM country
	WHERE country = 'India'
);
```

```sh
SQL Error [1241] [21000]: Operand should contain 1 column(s)
```

>[!warning] `피연산자` 는 하나의 `column` 만 포함해야 한다고 경고한다.


### 단일 열을 가진 다중 행을 반환하는 서브쿼리

서브쿼리가 두개 이상의 행을 반환할 경우, 동등조건을 사용할수 없다
대신 이런 유형의 서브쿼리와 함께 조건을 작성할 수 있는 $4$개의 추가 연산자가 있다

#### IN 연산자, NOT IN 연산자

단일 열을 가진 다중 행을 반환하는 서브쿼리는 하나의 집합의 개념으로 볼수 있다
다음은 단일 열을 가진 다중 행을 반환하는 쿼리이다

```mysql
SELECT country_id
FROM country
WHERE country = 'Canada' OR country = 'Mexico';
```

```sh
country_id|
----------+
        20|
        60|
```

이 쿼리는 `country_id` 가 $20$, $60$ 의 값을 가진 집합으로 볼 수 있다
이제 이 쿼리를 서브쿼리로 사용하여 조건을 작성한다.

```mysql
SELECT 
	city_id,
	city
FROM city
WHERE country_id IN (
	SELECT country_id
	FROM country
	WHERE country = 'Canada' OR country = 'Mexico'
);
```

```sh
city_id|city                      |
-------+--------------------------+
    179|Gatineau                  |
    196|Halifax                   |
    300|Lethbridge                |
    313|London                    |
    383|Oshawa                    |
	...
```

만약, `Canada` 와 `Mexico` 의 도시가 아닌 모든 도시의 데이터셋을 쿼리한다면 `NOT IN` 을 사용하면 된다.

#### ALL 연산자

`IN` 연산자는 하나의 표현식이 표현식 집합 내에 있는지 여부를 확인한다
반면 `ALL` 연산자는 한 집합의 모든 값과 하나의 값을 비교할수 있다.

```mysql
SELECT 
	frist_name,
	last_name
FROM customer
WHERE customer_id <> ALL(
	SELECT customer_id
	FROM payment
	WHERE amount = 0
);
```

```sh
first_name|last_name |
----------+----------+
MARY      |SMITH     |
PATRICIA  |JOHNSON   |
LINDA     |WILLIAMS  |
BARBARA   |JONES     |
ELIZABETH |BROWN     |
JENNIFER  |DAVIS     |
MARIA     |MILLER    |
SUSAN     |WILSON    |
...
```

이는 `customer_id` 의 값이 `ALL` 연산자의 집합에 포함되지 않는 모든 데이터셋을 반환한다.

>[!warning] 대부분의 사람들은 `ALL` 연산자 사용을 선호하지 않는다고 말한다.

`ALL` 대신 `NOT IN` 을 사용하여 동일한 쿼리를 만들 수 있다

```mysql
SELECT
	first_name,
	last_name
FROM customer
WHERE customer_id NOT IN (
	SELECT customer_id
	FROM payment
	WHERE amount = 0
);
```

>[!info] 이는 선호도의 문제라고 한다.

>[!warning] `NOT IN` 혹은 `ALL` 을 사용해서 하나의 집합 내의 값들과 비교할 경우, 집합에 `NULL` 값을 포함하지 않도록 해야 한다.<br><br>표현식의 왼쪽에 있는 값의 집합의 각 맴버와 비교하는데 `NULL` 값과 비교하면 `UNKNOWN` 이 발생한다.

```mysql
SELECT
	first_name,
	last_name
FROM customer
WHERE customer_id NOT IN (122, 452, NULL);
```

```sh
first_name|last_name|
----------+---------+
```

>[!warning] 이렇게 `UNKNOW` 이 발생하면 빈 집합을 반환한다..

`ALL` 연산자를 사용하는 다른예제로 `HAVING` 절에 있는 경우이다

```mysql
SELECT
	customer_id,
	COUNT(*)
FROM rental
GROUP BY customer_id
HAVING COUNT(*) > ALL(
	SELECT COUNT(*)
	FROM rental r
		INNER JOIN customer c
		ON r.customer_id = c.customer_id
		INNER JOIN address a
		ON a.address_id = c.address_id
		INNER JOIN city ct
		ON ct.city_id = a.city_id
		INNER JOIN country co
		ON ct.country_id = co.country_id
	WHERE co.country IN ('United States', 'Mexico', 'Canada')
	GROUP BY r.customer_id
);
```

```sh
customer_id|COUNT(*)|
-----------+--------+
        148|      46|
```

모든 북미 고객의 총 대여횟수보다 많은 대여횟수를 가진 고객을 쿼리한다.






