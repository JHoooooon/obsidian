서브쿼리를 적용할 다양한 방법이 존재한다.
이는 총 3가지 방법으로 나누어지는데

1. **사용자 정의 테이블 구성**
2. **조건을 작성**
3. **결과셋에서 열의 값을 생성**

이러한 방법을 보도록 한다.

## 데이터 소스로서의 서브쿼리

`SELECT` 문의 `FROM` 절에 쿼리에서 사용할 테이블들을 포함한다고 했다.

서브쿼리는 데이터의 행과 열을 포함하는 결과셋을 생성하므로, 테이블과 함께 `FROM` 절에서 서브쿼리르 포함하는것이 가능하다

```mysql
SELECT
	c.first_name,
	c.last_name ,
	pymnt.num_rentals,
	pymnt.tot_payments
FROM customer c
INNER JOIN (
	SELECT
		customer_id ,
		COUNT(*) num_rentals,
		SUM(amount) tot_payments
	FROM payment
	GROUP BY customer_id
) pymnt
ON c.customer_id = pymnt.customer_id;
```

```sh
irst_name|last_name |num_rentals|tot_payments|
---------+----------+-----------+------------+
ARY      |SMITH     |         32|      118.68|
ATRICIA  |JOHNSON   |         27|      128.73|
INDA     |WILLIAMS  |         26|      135.74|
ARBARA   |JONES     |         22|       81.78|
LIZABETH |BROWN     |         38|      144.62|
ENNIFER  |DAVIS     |         28|       93.72|
ARIA     |MILLER    |         33|      151.67|
...
```

`TABLE` 로써 사용가능하니, `INNER JOIN` 에서도 사용가능하다.
이는 굉장히 유연한 방식으로 사용가능하다.

마치 함수처럼 각 부분을 조립하고 조합해서 원하는 값들을 쿼리할수 있다.

>[!warning] `FROM` 절에서 사용되는 쿼리는 `비상관쿼리` 이어야 한다.

>[!info] 서브쿼리가 실행되고 포함 쿼리가 실행을 완료할때까지 데이터는 메모리에 보관된다. <br><br> 서브쿼리는 사용 가능한 테이블 집합을 훨씬 넘어서 원하는 데이터의 모든 `VIEW` 를 만든다음, 그 결과를 다른 테이블 또는 서브쿼리에 조인 할수 있으므로 쿼리를 작성할 때 탁월한 유연성을 제공한다.

### 데이터 구성

영화 대여에 지불한 금액을 기준으로 고객을 그룹화하기를 원한다.
데이터베이스에 저장되지 않은 새 그룹 정의를 사용해야 하며 다음처럼 구성되기를 원한다

| 그룹명           | 하한     | 상한              |
| :------------ | ------ | --------------- |
| Small Fry     | 0 달러   | 74.99 달러        |
| Average Joes  | 75 달러  | 149.99 달러       |
| Heavy Hitters | 150 달러 | 9,999,999.99 달러 |
이를 위한 쿼리는 다음과 같다

```mysql
SELECT 
	'Small Fry' name,
	0 low_limit,
	74.99 high_limit
UNION ALL
SELECT 
	'Average Joes' name,
	75 low_limit,
	149.99 high_limit
UNION ALL
SELECT 
	'Heavy Hitters' name,
	150 low_limit,
	999999999 high_limit
```

```sh
name         |low_limit|high_limit|
-------------+---------+----------+
Small Fry    |        0|     74.99|
Average Joes |       75|    149.99|
Heavy Hitters|      150|9999999.99|
```

이는 `UNION ALL`  을 사용하여, $3$ 개의 테이블을 하나로 합친다.
이를 사용하여 **지불한 금액을 기준으로 고객을 그룹화 한다**

```mysql
SELECT
	pymnt_grps.name,
	COUNT(*) num_customers
FROM (
	SELECT
	customer_id,
	COUNT(*) num_rentals,
	SUM(amount) tot_payments
	FROM payment
	GROUP BY customer_id
) pymnt
	INNER JOIN (
		SELECT
		'Small Fry' name,
		0 low_limit,
		74.99 high_limit
		UNION ALL
		SELECT
		'Average Joes' name,
		75 low_limit,
		149.99 high_limit
		UNION ALL
		SELECT
		'Heavy Hitters' name,
		150 low_limit,
		9999999.99 high_limit
	) pymnt_grps
	ON pymnt.tot_payments BETWEEN pymnt_grps.low_limit AND pymnt_grps.high_limit
GROUP BY pymnt_grps.name
```

```sh
name         |num_customers|
-------------+-------------+
Average Joes |          515|
Heavy Hitters|           46|
Small Fry    |           38|
```

`pymnt` 서브쿼리는 각 고객에 대한 총 영화 대여 횟수와 총 지불액을 반환하며, `pymnt_grps` 서브쿼리는 세개의 고객 그룹을 생성한다.

그리고 `pymnt`  의 `tot_pyments` 를 `pymnt_grps` 의 상한과 하한사이라면, `Column` 을 `JOIN` 해준다.

`GRUOP BY` 절을 사용하여, `pymnt_grps.name` 을 그룹화시켜준후, 그룹화된 `name` 과 `COUNT` 값을 반환한다.

이로인해, 해당 그룹화에 해당하는 총 고객수를 테이블로 표현가능하다

>[!info] 물론, 서브쿼리를 사용하는 대신 그룹 정의를 저장할 영구 테이블(또는 임시테이블)을 생성할 수 있다,<br><br>하지만 이러한 접근방식을 사용하면 얼마 후 데이터베이스가 특정 용도를 위한 작은 테이블로 가득 차게된다. <br><br> 명확한 비지니스 요구가 있는 경우에 한정해서 데이터베이스 테이블을 추가하도록 하는것이 데이터베이스 관리에 도움이 된다.<br><br> 이러한 서브쿼리는 이러한 관점에서 보면 적합하다고 볼 수 있다.

### 테스크 지향 서브쿼리

그룹을 생성하는 작업을 서브쿼리로 분리한 다음, 테스크 지향 서브쿼리는 

