
조인 조건을 지정하지 않고 여러 테이블을 조인한 결과인 데카르트 곱의 개념을 설명한다.

다음처럼 데카르트 곱을 생성하기 위해, 교차 조인을 지정한다

```mysql
SELECT
	c.name category_name,
	l.name language_name
FROM category c
	CROSS JOIN `language` l
```

```sh
category_name|language_name|
-------------+-------------+
Action       |German       |
Action       |French       |
Action       |Mandarin     |
Action       |Japanese     |
Action       |Italian      |
Action       |English      |
Animation    |German       |
Animation    |French       |
Animation    |Mandarin     |
Animation    |Japanese     |
Animation    |Italian      |
Animation    |English      |
Children     |German       |
Children     |French       |
Children     |Mandarin     |
Children     |Japanese     |
Children     |Italian      |
Children     |English      |
...
```

이 쿼리는 `cateogry` 테이블과 `language` 테이블의 데카르트 곱을 형성한다.

$$16(category 행) \times 6(language 행) = 96$$

이를 통해 $96$ 개의 행이 생성된다.
교차 조인이 유용하게 사용되는 예시는 다음과 같다

1 부터 399 까지의 데이터셋을 반환하는 쿼리

```mysql
SELECT
	ones.num + tens.num + hundreds.num
FROM
	(
		SELECT 0 num UNION ALL
		SELECT 1 num UNION ALL
		SELECT 2 num UNION ALL
		SELECT 3 num UNION ALL
		SELECT 4 num UNION ALL
		SELECT 5 num UNION ALL
		SELECT 6 num UNION ALL
		SELECT 7 num UNION ALL
		SELECT 8 num UNION ALL
		SELECT 9 num
	) ones
	CROSS JOIN
	(
		SELECT 0 num UNION ALL
		SELECT 10 num UNION ALL
		SELECT 20 num UNION ALL
		SELECT 30 num UNION ALL
		SELECT 40 num UNION ALL
		SELECT 50 num UNION ALL
		SELECT 60 num UNION ALL
		SELECT 70 num UNION ALL
		SELECT 80 num UNION ALL
		SELECT 90 num
	) tens
	CROSS JOIN
	(
		SELECT 0 num UNION ALL
		SELECT 100 num UNION ALL
		SELECT 200 num UNION ALL
		SELECT 300 num
	) hundreds
ORDER BY 1;
```

```sh
ones.num + tens.num + hundreds.num|
----------------------------------+
                                 0|
                                 1|
                                 2|
                                 3|
                                 4|
                                 5|
                                 6|
                                 7|
                                 8|
                                 9|
                                10|
                                11|
                                12|
                                13|
                                14|
                                15|
                                16|
								...	
                               394|
                               395|
                               396|
                               397|
                               398|
                               399|
```

재미있는 쿼리이다.
이는 다음의 원리와 같다

1. $\{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \}$,  $\{ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 \}$, $\{ 0, 100, 200, 300 \}$ 의 데카르트 곱을 계산한다.

2. 세열의 값을 더하면, $0 \sim 399$ 사이의 모든 숫자가 포함된다

이러한 성질을 이용하면 다음처럼 $2020/01/01$  부터 $2020/12/31$ 까지의 날짜를 구할수 있다.

```mysql
SELECT
	DATE_ADD('2020-01-01', INTERVAL (ones.num + tens.num + hundreds.num) DAY) dt
FROM
	(
		SELECT 0 num UNION ALL
		SELECT 1 num UNION ALL
		SELECT 2 num UNION ALL
		SELECT 3 num UNION ALL
		SELECT 4 num UNION ALL
		SELECT 5 num UNION ALL
		SELECT 6 num UNION ALL
		SELECT 7 num UNION ALL
		SELECT 8 num UNION ALL
		SELECT 9 num
	) ones
	CROSS JOIN
	(
		SELECT 0 num UNION ALL
		SELECT 10 num UNION ALL
		SELECT 20 num UNION ALL
		SELECT 30 num UNION ALL
		SELECT 40 num UNION ALL
		SELECT 50 num UNION ALL
		SELECT 60 num UNION ALL
		SELECT 70 num UNION ALL
		SELECT 80 num UNION ALL
		SELECT 90 num
	) tens
	CROSS JOIN
	(
		SELECT 0 num UNION ALL
		SELECT 100 num UNION ALL
		SELECT 200 num UNION ALL
		SELECT 300 num
	) hundreds
WHERE 
	DATE_ADD('2020-01-01', INTERVAL (ones.num + tens.num + hundreds.num) DAY) < '2021-01-01'
ORDER BY 1;
```

```sh
dt        |
----------+
2020-01-01|
2020-01-02|
2020-01-03|
2020-01-04|
2020-01-05|
2020-01-06|
2020-01-07|
2020-01-08|
2020-01-09|
2020-01-10|
...
2020-12-23|
2020-12-24|
2020-12-25|
2020-12-26|
2020-12-27|
2020-12-28|
2020-12-29|
2020-12-30|
2020-12-31|
```

이는 사용자의 개입 없이 결과셋에 추가 윤일을 자동으로 포함한다.
이를 사용하면 일별 대여횟수를 쿼리할수 있다.

```mysql
SELECT
	days.dt,
	COUNT(r.rental_id) num_rentals
FROM rental r
	RIGHT OUTER JOIN (
		SELECT
			DATE_ADD(
				'2005-01-01', 
				INTERVAL (ones.num + tens.num + hundreds.num) DAY
			) dt
		FROM (
				SELECT 0 num UNION ALL
				SELECT 1 num UNION ALL
				SELECT 2 num UNION ALL
				SELECT 3 num UNION ALL
				SELECT 4 num UNION ALL
				SELECT 5 num UNION ALL
				SELECT 6 num UNION ALL
				SELECT 7 num UNION ALL
				SELECT 8 num UNION ALL
				SELECT 9 num
			) ones
			CROSS JOIN
			(
				SELECT 0 num UNION ALL
				SELECT 10 num UNION ALL
				SELECT 20 num UNION ALL
				SELECT 30 num UNION ALL
				SELECT 40 num UNION ALL
				SELECT 50 num UNION ALL
				SELECT 60 num UNION ALL
				SELECT 70 num UNION ALL
				SELECT 80 num UNION ALL
				SELECT 90 num
			) tens
			CROSS JOIN
			(
				SELECT 0 num UNION ALL
				SELECT 100 num UNION ALL
				SELECT 200 num UNION ALL
				SELECT 300 num
			) hundreds
			WHERE DATE_ADD(
				'2005-01-01', 
				INTERVAL (
					ones.num + tens.num + hundreds.num
				) DAY) < '2006-01-01'
			ORDER BY 1
	) days
	ON days.dt = DATE(r.rental_date)
GROUP BY days.dt
ORDER BY 1;
```

```sh
dt        |num_rentals|
----------+-----------+
2005-01-01|          0|
2005-01-02|          0|
2005-01-03|          0|
2005-01-04|          0|
...
2005-05-21|          0|
2005-05-22|          0|
2005-05-23|          0|
2005-05-24|          8|
2005-05-25|        137|
2005-05-26|        174|
2005-05-27|        166|
...
```

이를 통해서, 일별 영화 대여 횟수를 찾는다.
이는 교차조인, 외부조인, 날짜 함수, 그룹화, 집계 함수를 포함한다. 

이러한 각 개념을 사용해서 창의적인 쿼리생성이 가능하다.






