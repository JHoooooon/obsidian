
분석함수에 대한 데이터 윈도우는 `PARTITION BY` 절을 사용하여 정의 되며,
공통 값 별로 행을 그룹화 할수 있다.

하지만 데이터 윈도우에 포함할 행을 더 세밀하게 제어하기 위해서 `frame` 하위절을 포함할 수 있다.

```mysql
SELECT
	YEARWEEK(payment_date) payment_week,
	SUM(amount) week_tot,
	SUM(SUM(amount))
		OVER (
		ORDER BY YEARWEEK(payment_date)
		ROWS UNBOUNDED PRECEDING
	) rolling_sum
FROM payment p
GROUP BY YEARWEEK(payment_date)
ORDER BY 1;
```

```sh
payment_week|week_tot|rolling_sum|
------------+--------+-----------+
      200521| 2846.19|    2846.19|
      200522| 1977.25|    4823.44|
      200524| 5603.43|   10426.87|
      200525| 4026.46|   14453.33|
      200527| 8490.83|   22944.16|
      200528| 5982.64|   28926.80|
      200530|11027.23|   39954.03|
      200531| 8412.07|   48366.10|
      200533|10619.11|   58985.21|
      200534| 7907.17|   66892.38|
      200607|  514.18|   67406.56|
```

이는 결과셋의 시작 부분부터 현재 행 까지의 데이터 윈도우를 정의하기 위해 제한없는 **선행하위절**(**ROWS UNBOUNDED PRESCEDING**)을 포함한다.

다음은 지급액의 3 주 롤링 평균을 계산한다.

```mysql
SELECT
	YEARWEEK(payment_date) payment_week,
	SUM(amount) week_tot,
	ROUND(
		AVG(SUM(amount))
		OVER (
			ORDER BY YEARWEEK(payment_date)
			ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
		), 
	1) rolling_3wk_avg
FROM payment p
GROUP BY YEARWEEK(payment_date)
ORDER BY 1;
```

```sh
payment_week|week_tot|rolling_3wk_avg|
------------+--------+---------------+
      200521| 2846.19|        2411.72|
      200522| 1977.25|        3475.62|
      200524| 5603.43|        3869.05|
      200525| 4026.46|        6040.24|
      200527| 8490.83|        6166.64|
      200528| 5982.64|        8500.23|
      200530|11027.23|        8473.98|
      200531| 8412.07|       10019.47|
      200533|10619.11|        8979.45|
      200534| 7907.17|        6346.82|
      200607|  514.18|        4210.68|
```

이는 현재행, 이전행, 다음 행 총 `3` 주의 평균을 구하고, `ROUND` 하는 쿼리이다.
하지만, 첫째 행, 마지막 행에 대해서는 이전 행 혹은 다음 행이 없다.

이럴 경우, 첫째 행은 현재 행, 다음 행의 평균을 계산하고, 마지막 행은 현재 행, 이전 행의 평균을 계산한다.

만약 행수가 아닌 날짜의 간격을 지정하려면, 윈도우의 범위를 지정할 수 있다.

> [!info] 만약, `payment_week` 열에서 `200525`, `200527`, `200528` 순으로 3행의 평균값을 구한다고 해보자.<br><br> 그럼 `200525` 다음은 `200527` 로 계산된다.<br>이는 원래의 목적과 다르게 계산될 여지가 있다.

```mysql
SELECT
	DATE(payment_date) date,
	SUM(amount) tot,
	AVG(SUM(amount)) OVER (
		ORDER BY DATE(payment_date)
		RANGE BETWEEN INTERVAL 3 DAY PRECEDING
			AND INTERVAL 3 DAY FOLLOWING
	) 7_day_avg
FROM payment p
GROUP BY DATE(payment_date)
ORDER BY 1;
```

```sh
date      |tot    |7_day_avg  |
----------+-------+-----------+
2005-05-24|  29.92| 510.537500|
2005-05-25| 573.63| 569.238000|
2005-05-26| 754.26| 582.441667|
2005-05-27| 684.34| 589.010000|
2005-05-28| 804.04| 684.788571|
2005-05-29| 648.46| 703.315000|
2005-05-30| 628.42| 693.126000|
2005-05-31| 700.37| 695.322500|
2005-06-14|  57.84|1029.217500|
2005-06-15|1376.52|1120.686000|
2005-06-16|1349.76|1180.658333|
2005-06-17|1332.75|1209.805714|
2005-06-18|1486.56|1367.435714|
2005-06-19|1480.52|1365.921667|
2005-06-20|1384.69|1369.154000|
```

이를 사용하여 날짜에 대한 계산이 가능하다.

위의 예시는 현재 행의 $\pm3$ 일의 범위를 지정하여, `payment_date` 값이 해당 범위에 속하는 행만 포함한다.

